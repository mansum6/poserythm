<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Pose Detection</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #222;
      color: #fff;
    }
    #poseText {
      margin: 20px;
      font-size: 3rem;
      font-weight: bold;
    }
    #videoContainer {
      position: relative;
      width: 640px;
      height: 480px;
    }
    video, canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    canvas { pointer-events: none; }
  </style>
</head>
<body>

  <div id="poseText">Initializing…</div>
  <div id="videoContainer">
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <script type="importmap">
  {
    "imports": {
      "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
      "@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
    }
  }
  </script>

  <script type="module">
    import * as tf from '@tensorflow/tfjs';
    import { createDetector, SupportedModels, poseDetection , util } from '@tensorflow-models/pose-detection';

    // ------------------------------------------------------------------------
    // 1) CONFIG & STATE
    // ------------------------------------------------------------------------
    const POSE_STATES = {
      IDLE: 'IDLE',
      PUNCH_LEFT: 'PUNCH_LEFT',
      PUNCH_RIGHT: 'PUNCH_RIGHT',
      PUNCH_BOTH: 'PUNCH_BOTH',
      LEAN_LEFT: 'LEAN_LEFT',
      LEAN_RIGHT: 'LEAN_RIGHT',
      DUCK: 'DUCK',
      POSE_INCOMPLETE: 'POSE_INCOMPLETE',
      POSE_LOST: 'POSE_LOST'
    };

    const CONFIG = {
      minPoseConfidence: 0.3,
      poseSmoothFactor: 0.8,
      minTorsoHeight: 20,          // in pixels
      minShoulderWidth: 15,        // in pixels
      torsoChangeThreshold: 0.3,
      duckThresholdRatio: 0.25,
      leanThresholdX: 0.2,         // fraction of shoulder width
      punchThresholdX: 0.3         // fraction of shoulder width
    };

    const essentialNames = [
      'nose','left_shoulder','right_shoulder',
      'left_hip','right_hip',
      'left_wrist','right_wrist',
      'left_elbow','right_elbow'
    ];

    const gameState = {
      smoothedKeypoints: {},
      lastTorsoHeight: null,
      standingNoseY: null,
      ducking: false
    };

    // ------------------------------------------------------------------------
    // 2) SMOOTHING & HELPER FUNCTIONS
    // ------------------------------------------------------------------------
    function _smoothAndGetKeypoint(name, keypointMap) {
      const kp = keypointMap[name];
      if (!kp) return null;
      let sk = gameState.smoothedKeypoints[name];
      if (!sk) {
        gameState.smoothedKeypoints[name] = { x: kp.x, y: kp.y, score: kp.score };
        return gameState.smoothedKeypoints[name];
      }
      const f = CONFIG.poseSmoothFactor;
      sk.x = f * sk.x + (1 - f) * kp.x;
      sk.y = f * sk.y + (1 - f) * kp.y;
      sk.score = kp.score;
      return sk;
    }

    function _checkPunch(w, e, s, isLeft, shoulderMidY, shoulderWidth) {
      if (!w || !e || !s) return false;
      // is the wrist in front of the elbow relative to shoulder?
      const wristAhead = isLeft
        ? (w.x > e.x && e.x > s.x)
        : (w.x < e.x && e.x < s.x);
      if (!wristAhead) return false;
      const seDist = Math.abs(s.x - e.x);
      const ewDist = Math.abs(e.x - w.x);
      const alignedY = Math.abs(w.y - shoulderMidY) < shoulderWidth * 0.6;
      return seDist > 5 && ewDist > CONFIG.punchThresholdX * seDist && alignedY;
    }

    function interpretPose(keypoints) {
      if (!keypoints || keypoints.length === 0) {
        return POSE_STATES.POSE_LOST;
      }
      // filter reliable
      const reliable = keypoints.filter(p => p.score >= CONFIG.minPoseConfidence && p.name);
      if (reliable.length === 0) {
        return POSE_STATES.POSE_LOST;
      }
      if (reliable.length < essentialNames.length) {
        return POSE_STATES.POSE_INCOMPLETE;
      }
      // full set: build a map
      const keypointMap = Object.fromEntries(reliable.map(p => [p.name, p]));

      // smooth
      const ek = {};
      for (let n of essentialNames) {
        ek[n] = _smoothAndGetKeypoint(n, keypointMap);
      }
      const { nose, left_shoulder: ls, right_shoulder: rs,
              left_hip: lh, right_hip: rh,
              left_wrist: lw, right_wrist: rw,
              left_elbow: le, right_elbow: re } = ek;

      // torso dims
      const shoulderMidY = (ls.y + rs.y) / 2;
      const shoulderMidX = (ls.x + rs.x) / 2;
      const hipMidY = (lh.y + rh.y) / 2;
      const hipMidX = (lh.x + rh.x) / 2;
      const torsoHeight = Math.abs(shoulderMidY - hipMidY);
      const shoulderWidth = Math.abs(ls.x - rs.x);

      if (torsoHeight < CONFIG.minTorsoHeight || shoulderWidth < CONFIG.minShoulderWidth) {
        return POSE_STATES.POSE_LOST;
      }

      // update standing nose
      const lastTorso = gameState.lastTorsoHeight;
      if (lastTorso && Math.abs(torsoHeight - lastTorso)/lastTorso > CONFIG.torsoChangeThreshold) {
        gameState.standingNoseY = nose.y;
      }
      gameState.lastTorsoHeight = torsoHeight;
      if (!gameState.standingNoseY) {
        gameState.standingNoseY = nose.y;
      }

      // duck detection
      const drop = (nose.y - gameState.standingNoseY) / torsoHeight;
      if (!gameState.ducking && drop > CONFIG.duckThresholdRatio) {
        gameState.ducking = true;
        return POSE_STATES.DUCK;
      }
      if (gameState.ducking && drop < CONFIG.duckThresholdRatio * 0.5) {
        gameState.ducking = false;
      }
      if (gameState.ducking) {
        return POSE_STATES.DUCK;
      }

      // lean detection
      const leanOffset = shoulderMidX - hipMidX;
      const leanThr = CONFIG.leanThresholdX * shoulderWidth;
      if (leanOffset > leanThr) return POSE_STATES.LEAN_LEFT;
      if (leanOffset < -leanThr) return POSE_STATES.LEAN_RIGHT;

      // punch detection
      const leftPunch = _checkPunch(lw, le, ls, true, shoulderMidY, shoulderWidth);
      const rightPunch = _checkPunch(rw, re, rs, false, shoulderMidY, shoulderWidth);

      if (leftPunch && rightPunch)    return POSE_STATES.PUNCH_BOTH;
      if (rightPunch)                 return POSE_STATES.PUNCH_RIGHT;
      if (leftPunch)                  return POSE_STATES.PUNCH_LEFT;

      return POSE_STATES.IDLE;
    }

    // ------------------------------------------------------------------------
    // 3) SET UP VIDEO + CANVAS + POSE DETECTOR + LOOP
    // ------------------------------------------------------------------------
    const video    = document.getElementById('video');
    const canvas   = document.getElementById('overlay');
    const ctx      = canvas.getContext('2d');
    const poseText = document.getElementById('poseText');

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: { width: 640, height: 480 }
      });
      video.srcObject = stream;
      return new Promise(resolve => {
        video.onloadedmetadata = () => {
          video.play();
          resolve(video);
        };
      });
    }

    async function main() {
      await setupCamera();
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;

      // create MoveNet detector
      const detector = await createDetector(SupportedModels.MoveNet, {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
      });


      async function renderFrame() {
        // 1) estimate poses
        const poses = await detector.estimatePoses(video, {
          maxPoses: 1,
          flipHorizontal: false
        });
        const kps = poses[0]?.keypointsWithScore || poses[0]?.keypoints || [];
        // unify naming:
        // Some backends use .name, others use .part – both are OK.
        (kps || []).forEach(p => {
          if (!p.name && p.part) p.name = p.part;
        });

        // 2) interpret
        const state = interpretPose(kps);
        poseText.innerText = state;

        // 3) draw video frame onto canvas
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        // 4) draw keypoints + skeleton
        const adj = util.getAdjacentPairs(SupportedModels.MoveNet);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'lime';
        for (let [i,j] of adj) {
          const a = kps[i], b = kps[j];
          if (a && b && a.score>CONFIG.minPoseConfidence && b.score>CONFIG.minPoseConfidence) {
            ctx.beginPath();
            ctx.moveTo(a.x * canvas.width, a.y * canvas.height);
            ctx.lineTo(b.x * canvas.width, b.y * canvas.height);
            ctx.stroke();
          }
        }
        for (let p of kps) {
          if (p.score > CONFIG.minPoseConfidence) {
            ctx.beginPath();
            ctx.arc(p.x * canvas.width, p.y * canvas.height, 5, 0, Math.PI*2);
            ctx.fillStyle = 'red';
            ctx.fill();
          }
        }

        requestAnimationFrame(renderFrame);
      }
      renderFrame();
    }

    main();
  </script>
</body>
</html>
