<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pose Detector</title>
  <script type="importmap">
  {
    "imports": {
      "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
      "@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
    }
  }
  </script>
  <style>
    body, html { margin:0; padding:0; background:#222; color:#fff; font-family:sans-serif; }
    #poseText { font-size:2.5rem; text-align:center; padding:10px; }
    #container { position:relative; width:640px; margin:0 auto; }
    #video { width:100%; transform: scaleX(-1); /* mirror for selfie view */ }
    #overlay {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
      transform: scaleX(-1); /* match video */
    }
  </style>
</head>
<body>
  <div id="poseText">Loading camera…</div>
  <div id="container">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <script type="module">
  import * as tf from '@tensorflow/tfjs';
  import * as poseDetection from '@tensorflow-models/pose-detection';

  //---- CONFIG & STATE ----
  const CONFIG = {
    minPoseConfidence: 0.3,
    poseSmoothFactor: 0.8,
    minTorsoHeight: 30,      // px
    minShoulderWidth: 30,    // px
    torsoChangeThreshold: 0.2,
    duckThresholdRatio: 0.25,
    leanThresholdX: 0.15,     // fraction of shoulder width
    punchThresholdX: 0.3,
  };

  const POSE_STATES = {
    IDLE:        'IDLE',
    PUNCH_LEFT:  'PUNCH_LEFT',
    PUNCH_RIGHT: 'PUNCH_RIGHT',
    LEAN_LEFT:   'LEAN_LEFT',
    LEAN_RIGHT:  'LEAN_RIGHT',
    DUCK:        'DUCK',
    POSE_INCOMPLETE: 'POSE_INCOMPLETE',
    PUNCH_BOTH: 'PUNCH_BOTH',
    POSE_LOST:  'POSE_LOST'
  };

  const essentialNames = ["nose","left_shoulder","right_shoulder","left_hip","right_hip","left_wrist","right_wrist","left_elbow","right_elbow"];
  let gameState = {
    smoothedKeypoints: {},
    lastTorsoHeight: null,
    standingNoseY: null,
    ducking: false
  };

  // smoothing helper
  function _smoothAndGetKeypoint(name, keypointMap) {
    const kp = keypointMap[name];
    if (!kp) return null;
    let sk = gameState.smoothedKeypoints[name];
    if (!sk) {
      sk = { x: kp.x, y: kp.y, score: kp.score };
      gameState.smoothedKeypoints[name] = sk;
      return sk;
    }
    const f = CONFIG.poseSmoothFactor;
    sk.x = f*sk.x + (1-f)*kp.x;
    sk.y = f*sk.y + (1-f)*kp.y;
    sk.score = kp.score;
    return sk;
  }

  // detect a punch on one side
  function _checkPunch(w, e, s, isLeft, shoulderMidY, shoulderWidth) {
    if (!w||!e||!s) return false;
    // wrist further out than elbow relative to shoulder
    const wristAhead = isLeft
      ? (w.x > e.x && e.x > s.x)
      : (w.x < e.x && e.x < s.x);
    if (!wristAhead) return false;
    const seDist = Math.abs(s.x - e.x);
    const ewDist = Math.abs(e.x - w.x);
    const alignedY = Math.abs(w.y - shoulderMidY) < shoulderWidth * 0.6;
    return seDist > 5 && ewDist > CONFIG.punchThresholdX * seDist && alignedY;
  }

  // core interpret
  function interpretPose(keypoints) {
    if (!keypoints || keypoints.length===0) return POSE_STATES.POSE_LOST;
    // build name→kp map with confidence filter
    const kpMap = Object.fromEntries(
      keypoints
        .filter(p => p.name && p.score!=null && p.score >= CONFIG.minPoseConfidence)
        .map(p => [p.name, p])
    );
    // check counts
    const present = essentialNames.filter(n => kpMap[n]);
    if (present.length===0) return POSE_STATES.POSE_LOST;
    if (present.length < essentialNames.length) return POSE_STATES.POSE_INCOMPLETE;

    // smooth & extract
    const es = {};
    for (let n of essentialNames) {
      es[n] = _smoothAndGetKeypoint(n, kpMap);
    }
    const { nose, left_shoulder: ls, right_shoulder: rs,
            left_hip: lh, right_hip: rh,
            left_wrist: lw, right_wrist: rw,
            left_elbow: le, right_elbow: re } = es;

    // midpoints & measures
    const shoulderMidY = (ls.y + rs.y)/2;
    const shoulderMidX = (ls.x + rs.x)/2;
    const hipMidY = (lh.y + rh.y)/2;
    const hipMidX = (lh.x + rh.x)/2;
    const torsoHeight = Math.abs(shoulderMidY - hipMidY);
    const shoulderWidth = Math.abs(ls.x - rs.x);

    if (torsoHeight < CONFIG.minTorsoHeight || shoulderWidth < CONFIG.minShoulderWidth) {
      return POSE_STATES.POSE_LOST;
    }

    // track standing nose Y for duck detection
    if (gameState.lastTorsoHeight != null) {
      if (Math.abs(torsoHeight - gameState.lastTorsoHeight)/gameState.lastTorsoHeight > CONFIG.torsoChangeThreshold) {
        gameState.standingNoseY = nose.y;
      }
    }
    gameState.lastTorsoHeight = torsoHeight;
    if (!gameState.standingNoseY) {
      gameState.standingNoseY = nose.y;
    }

    // duck?
    const normalizedDrop = (nose.y - gameState.standingNoseY)/torsoHeight;
    if (!gameState.ducking && normalizedDrop > CONFIG.duckThresholdRatio) {
      gameState.ducking = true;
      return POSE_STATES.DUCK;
    }
    if (gameState.ducking && normalizedDrop < CONFIG.duckThresholdRatio*0.5) {
      gameState.ducking = false;
    }
    if (gameState.ducking) return POSE_STATES.DUCK;

    // lean?
    const leanOffset = shoulderMidX - hipMidX;
    const leanThresh = CONFIG.leanThresholdX * shoulderWidth;
    if (leanOffset > leanThresh)  return POSE_STATES.LEAN_LEFT;
    if (leanOffset < -leanThresh) return POSE_STATES.LEAN_RIGHT;

    // punches
    const leftPunch  = _checkPunch(lw, le, ls, true,  shoulderMidY, shoulderWidth);
    const rightPunch = _checkPunch(rw, re, rs, false, shoulderMidY, shoulderWidth);
    if (leftPunch && rightPunch) return POSE_STATES.PUNCH_BOTH;
    if (leftPunch)  return POSE_STATES.PUNCH_LEFT;
    if (rightPunch) return POSE_STATES.PUNCH_RIGHT;

    return POSE_STATES.IDLE;
  }

  // draw keypoints on canvas
  function drawKeypoints(ctx, keypoints) {
    ctx.fillStyle = 'lime';
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth = 2;
    for (let n of essentialNames) {
      const kp = gameState.smoothedKeypoints[n];
      if (!kp || kp.score < CONFIG.minPoseConfidence) continue;
      ctx.beginPath();
      ctx.arc(kp.x, kp.y, 5, 0, 2*Math.PI);
      ctx.fill();
      ctx.stroke();
    }
  }

  //---- MAIN LOOP ----
  async function main() {
    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const poseText = document.getElementById('poseText');

    // webcam
    const stream = await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}, audio:false});
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    video.play();

    // match canvas size
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // load detector
    const detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING}
    );
    poseText.innerText = 'Initializing...';

    // render loop
    async function frameLoop() {
      const poses = await detector.estimatePoses(video);
      const state = interpretPose(poses[0]?.keypoints || []);
      poseText.innerText = state;
      // clear & draw overlay
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawKeypoints(ctx, gameState.smoothedKeypoints);

      requestAnimationFrame(frameLoop);
    }
    frameLoop();
  }

  main().catch(err => {
    console.error(err);
    document.getElementById('poseText').innerText = 'Error: ' + err.message;
  });

  </script>
</body>
</html>
