<!DOCTYPE html>
<html>
<head>
  <title>Pose Detection Optimized</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #333; color: #eee;}
    #video-container { position: relative; width: 640px; height: 480px; border: 1px solid #555;}
    video { display: block; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); }
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%;}
    #poseText { font-size: 2em; color: #ffae00; margin-top: 10px; min-height: 1.2em;}
    #controls-area { display: flex; margin-top: 20px; width: 90%; max-width: 1000px; justify-content: space-around;}
    .panel { background-color: #444; padding: 15px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.5); margin:10px; }
    .panel h3 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; color: #00bcd4;}
    #console-output-area { width: 100%; max-height: 150px; overflow-y: auto; border: 1px solid #555; background-color: #2a2a2a; padding: 5px; box-sizing: border-box; font-size: 0.8em; margin-top:10px;}
    #console-output-area p { margin: 2px 0; white-space: pre-wrap; word-break: break-word; }
    #console-output-area p.log { color: #ccc; }
    #console-output-area p.warn { color: #ffcc00; }
    #console-output-area p.error { color: #ff6b6b; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
      "@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
    }
  }
  </script>
</head>
<body>
  <h1>PoseNet Real-time Detection</h1>
  <div id="video-container">
    <video id="video" playsinline autoplay muted></video>
    <canvas id="overlay"></canvas>
  </div>
  <div id="poseText">Loading...</div>

  <script type="module">
    import * as tf from '@tensorflow/tfjs';
    import * as poseDetection from '@tensorflow-models/pose-detection';

    // Simulated import for demonstration (replace with your actual module)
    import {
      interpretPose as interpretPoseFromModule,
      POSE_STATES,
      POSE_DETECTION_CONFIG,
      getSmoothedKeypoints,
      getPoseDetectionInternalState,
      resetPoseDetectionState
    } from './poseDetection2.js';

    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');

    const poseTextEl = document.getElementById('poseText');

    // ðŸŽ¨ Pose Color Map
    const poseColors = {
      PUNCH_RIGHT: '#00ff00', // Green
      PUNCH_LEFT: '#ff0000',  // Red
      PUNCH_BOTH: '#0000ff',  // Blue
      DEFAULT: '#ffae00'      // Default orange
    };

    // ðŸ” Update pose text and color
    function updatePoseText(pose) {
      poseTextEl.textContent = pose;
      poseTextEl.style.color = poseColors[pose] || poseColors.DEFAULT;
    }

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: { facingMode: 'user', width: 640, height: 480 }
      });
      video.srcObject = stream;
      return new Promise((resolve) => {
        video.onloadedmetadata = () => {
          resolve(video);
        };
      });
    }

    async function init() {
      await setupCamera();
      video.play();

      const detector = await poseDetection.createDetector(
        poseDetection.SupportedModels.MoveNet,
        {
          modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
        }
      );

      const detectPose = async () => {
        const poses = await detector.estimatePoses(video);
        if (poses.length > 0) {
          const pose = interpretPoseFromModule(poses[0]);
          updatePoseText(pose);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawKeypoints(ctx, video.videoWidth);

        requestAnimationFrame(detectPose);
      };

      detectPose();
    }

    function drawKeypoints(ctx, videoWidthForRefLine) {
      const smoothedKeypoints = getSmoothedKeypoints();
      const poseModuleState = getPoseDetectionInternalState();

      ctx.fillStyle = 'lime';
      ctx.strokeStyle = 'yellow';
      ctx.lineWidth = 1;
      const radius = 5;

      for (const name in smoothedKeypoints) {
        const kp = smoothedKeypoints[name];
        if (!kp || kp.score < POSE_DETECTION_CONFIG.minPoseConfidence) continue;
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
    }

    init();
  </script>
</body>
</html>
