<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pose Detection Optimized</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #333; color: #eee;}
    #video-container { position: relative; width: 640px; height: 480px; border: 1px solid #555;}
    video { display: block; width: 100%; height: 100%; object-fit: contain; transform: scaleX(-1); } /* Mirror video via CSS */
    #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%;}
    #poseText { font-size: 2em; color: #ffae00; margin-top: 10px; min-height: 1.2em; text-align: center;}
    #controls-area { display: flex; margin-top: 20px; width: 90%; max-width: 1000px; justify-content: space-around; flex-wrap: wrap;}
    .panel { background-color: #444; padding: 15px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.5); margin:10px; flex: 1; min-width: 300px;}
    .panel h3 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; color: #00bcd4;}
    #console-output-area { width: 100%; max-height: 150px; overflow-y: auto; border: 1px solid #555; background-color: #2a2a2a; padding: 5px; box-sizing: border-box; font-size: 0.8em; margin-top:10px;}
    #console-output-area p { margin: 2px 0; white-space: pre-wrap; word-break: break-all; }
    #console-output-area p.log { color: #ccc; }
    #console-output-area p.warn { color: #ffcc00; }
    #console-output-area p.error { color: #ff6b6b; }
    #config-vars-list .config-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    #config-vars-list label { margin-right: 10px; flex-basis: 50%; font-size: 0.9em; }
    #config-vars-list input { flex-grow: 1; margin-right: 10px; padding: 4px; background: #555; color: #eee; border: 1px solid #666; border-radius: 3px;}
    #config-vars-list button { padding: 4px 8px; background: #007bff; color: white; border:none; border-radius: 3px; cursor: pointer;}
    #config-vars-list button:hover { background: #0056b3; }
    #configStatus { font-size: 0.9em; margin-top: 10px; min-height: 1.1em; text-align: center;}
    .debug-value { margin-bottom: 3px; font-size: 0.9em; }
    .debug-label { font-weight: bold; color: #87ceeb; }
    .debug-value-content { margin-left: 5px; color: #fafad2;}
  </style>
  <script type="importmap">
{
"imports": {
"@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
"@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
}
}
</script>
</head>
<body>
  <h1>PoseNet Real-time Detection (MoveNet)</h1>
  <div id="video-container">
    <video id="video" playsinline autoplay muted width="640" height="480"></video>
    <canvas id="overlay" width="640" height="480"></canvas>
  </div>
  <div id="poseText">Loading...</div>

  <div id="controls-area">
    <div class="panel" id="config-panel">
      <h3>App Configuration</h3>
      <div id="config-vars-list"></div>
      <p id="configStatus">Loading config...</p>
      <button id="resetPoseStateButton" style="margin-top:10px; background-color: #dc3545; color:white; border:none; padding: 8px 12px; border-radius: 3px; cursor:pointer;">Reset Pose State</button>
    </div>
    <div class="panel" id="debug-panel">
      <h3>Debug Values</h3>
      <div id="debug-values"></div>
    </div>
  </div>
  <div class="panel" id="console-panel" style="width: 90%; max-width: 1000px;">
      <h3>Console Output</h3>
      <div id="console-output-area"></div>
  </div>

  <script type="module">
    import * as tf from '@tensorflow/tfjs';
    import * as poseDetection from '@tensorflow-models/pose-detection';
    import {
      interpretPose as interpretPoseFromModule,
      POSE_STATES, 
      POSE_DETECTION_CONFIG, 
      getSmoothedKeypoints,
      getPoseDetectionInternalState,
      resetPoseDetectionState
    } from './poseDetection2.js'; // Adjust path if necessary

    const consoleOutputDiv = document.getElementById('console-output-area');
    const debugValuesDiv = document.getElementById('debug-values');
    const debugValueSpansCache = {};

    function updateDebugValue(label, value) {
      const id = `debug-${label.replace(/\s+/g, '-').toLowerCase()}`;
      let valueSpan = debugValueSpansCache[id];

      if (!valueSpan) {
        let elem = document.getElementById(id);
        if (!elem) {
          elem = document.createElement('div');
          elem.id = id;
          elem.className = 'debug-value';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'debug-label';
          labelSpan.textContent = label + ':';
          const newValueSpan = document.createElement('span');
          newValueSpan.className = 'debug-value-content';
          elem.appendChild(labelSpan);
          elem.appendChild(newValueSpan);
          debugValuesDiv.appendChild(elem);
          valueSpan = newValueSpan;
        } else {
          valueSpan = elem.querySelector('.debug-value-content');
        }
        debugValueSpansCache[id] = valueSpan;
      }
      valueSpan.textContent = typeof value === 'number' ? value.toFixed(4) : String(value);
    }

    let logElementsQueue = [];
    const APP_CONFIG = { 
      maxLogMessages: 50,
      drawKeypointRadius: 5,
      drawSkeletonLineWidth: 2,
      drawKeypointFillColor: 'lime',
      drawKeypointStrokeColor: 'yellow',
      drawSkeletonColor: 'aqua',
      standingRefLineColor: 'cyan',
      duckingRefLineColor: 'red',
      defaultPoseTextColor: '#ffae00', // Original color from CSS
      punchBothColor: '#FF4136', // Red
      punchLeftColor: '#0074D9', // Blue
      punchRightColor: '#2ECC40', // Green
    };
    const appIntegerConfigVars = ['maxLogMessages', 'drawKeypointRadius', 'drawSkeletonLineWidth'];

    function logToScreen(message, type = 'log') {
      if (!consoleOutputDiv) return;
      let pElement;
      if (logElementsQueue.length < APP_CONFIG.maxLogMessages) {
        pElement = document.createElement('p');
        logElementsQueue.push(pElement);
        consoleOutputDiv.appendChild(pElement);
      } else {
        pElement = logElementsQueue.shift();
        consoleOutputDiv.appendChild(pElement);
        logElementsQueue.push(pElement);
      }
      const GTMtimestamp = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'});
      pElement.textContent = `[${GTMtimestamp} ${type.toUpperCase()}]: ${message}`;
      pElement.className = type;
      consoleOutputDiv.scrollTop = consoleOutputDiv.scrollHeight;
    }

    const originalConsoleLog = console.log;
    const originalConsoleError = console.error;
    const originalConsoleWarn = console.warn;
    console.log = (...args) => {
      originalConsoleLog.apply(console, args);
      logToScreen(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '), 'log');
    };
    console.error = (...args) => {
      originalConsoleError.apply(console, args);
      logToScreen(args.map(arg => String(arg)).join(' '), 'error');
    };
    console.warn = (...args) => {
      originalConsoleWarn.apply(console, args);
      logToScreen(args.map(arg => String(arg)).join(' '), 'warn');
    };

    let appState = { 
        frameCounter: 0,
    };

    function drawKeypoints(ctx, videoWidthForRefLine) { 
      const smoothedKeypoints = getSmoothedKeypoints(); 
      const poseModuleState = getPoseDetectionInternalState(); 

      ctx.fillStyle = APP_CONFIG.drawKeypointFillColor;
      ctx.strokeStyle = APP_CONFIG.drawKeypointStrokeColor;
      ctx.lineWidth = 1;
      ctx.translate(ctx.canvas.width, 0); // Move origin to the right edge
      ctx.scale(-1, 1); // Flip horizontally
      const radius = APP_CONFIG.drawKeypointRadius;

      for (const name in smoothedKeypoints) {
        const kp = smoothedKeypoints[name];
        if (!kp || kp.score < POSE_DETECTION_CONFIG.minPoseConfidence) continue;
        ctx.beginPath();
        ctx.arc(kp.x, kp.y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
      }
      
      if (poseModuleState.standingNoseY) {
        ctx.beginPath();
        ctx.strokeStyle = poseModuleState.ducking ? APP_CONFIG.duckingRefLineColor : APP_CONFIG.standingRefLineColor;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.moveTo(0, poseModuleState.standingNoseY);
        ctx.lineTo(videoWidthForRefLine, poseModuleState.standingNoseY); 
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      ctx.beginPath();
      ctx.strokeStyle = APP_CONFIG.drawSkeletonColor;
      ctx.lineWidth = APP_CONFIG.drawSkeletonLineWidth;

      const skp = smoothedKeypoints;
      const canDraw = (...kps) => kps.every(kpName => skp[kpName] && skp[kpName].score >= POSE_DETECTION_CONFIG.minPoseConfidence);

      if (canDraw("nose", "left_shoulder")) { ctx.moveTo(skp.nose.x, skp.nose.y); ctx.lineTo(skp.left_shoulder.x, skp.left_shoulder.y); }
      if (canDraw("nose", "right_shoulder")) { ctx.moveTo(skp.nose.x, skp.nose.y); ctx.lineTo(skp.right_shoulder.x, skp.right_shoulder.y); }
      if (canDraw("left_shoulder", "right_shoulder")) { ctx.moveTo(skp.left_shoulder.x, skp.left_shoulder.y); ctx.lineTo(skp.right_shoulder.x, skp.right_shoulder.y); }
      if (canDraw("left_shoulder", "left_hip")) { ctx.moveTo(skp.left_shoulder.x, skp.left_shoulder.y); ctx.lineTo(skp.left_hip.x, skp.left_hip.y); }
      if (canDraw("right_shoulder", "right_hip")) { ctx.moveTo(skp.right_shoulder.x, skp.right_shoulder.y); ctx.lineTo(skp.right_hip.x, skp.right_hip.y); }
      if (canDraw("left_hip", "right_hip")) { ctx.moveTo(skp.left_hip.x, skp.left_hip.y); ctx.lineTo(skp.right_hip.x, skp.right_hip.y); }
      if (canDraw("left_shoulder", "left_elbow", "left_wrist")) { ctx.moveTo(skp.left_shoulder.x, skp.left_shoulder.y); ctx.lineTo(skp.left_elbow.x, skp.left_elbow.y); ctx.lineTo(skp.left_wrist.x, skp.left_wrist.y); }
      if (canDraw("right_shoulder", "right_elbow", "right_wrist")) { ctx.moveTo(skp.right_shoulder.x, skp.right_shoulder.y); ctx.lineTo(skp.right_elbow.x, skp.right_elbow.y); ctx.lineTo(skp.right_wrist.x, skp.right_wrist.y); }
      
      ctx.stroke();
    }

    function setupConfigControls() {
        const configVarsListDiv = document.getElementById('config-vars-list');
        const statusP = document.getElementById('configStatus');
        configVarsListDiv.innerHTML = '';

        const configsToDisplay = {
            "App Config": {config: APP_CONFIG, integerVars: appIntegerConfigVars},
            "Pose Detection Config": {config: POSE_DETECTION_CONFIG, integerVars: [
                'minTorsoHeight', 'minShoulderWidth', 'temporarilyIncompleteDurationMs',
                'standingHeightWindowSize', 'minimumDuckDistance', 'punchMinPixelSEDistance',
                'minFramesForValidStandingHeight', 'smoothingPasses', 'minEssentialKeypointsForValidPose'
            ]}
        };

        for (const sectionName in configsToDisplay) {
            const sectionHeader = document.createElement('h4');
            sectionHeader.textContent = sectionName;
            sectionHeader.style.marginTop = "15px";
            sectionHeader.style.borderTop = "1px dashed #666";
            sectionHeader.style.paddingTop = "10px";
            configVarsListDiv.appendChild(sectionHeader);

            const configObject = configsToDisplay[sectionName].config;
            const integerVarsInSection = configsToDisplay[sectionName].integerVars || [];

            for (const key in configObject) {
                if (Object.hasOwnProperty.call(configObject, key)) {
                    // Don't create inputs for color strings in APP_CONFIG, they are fixed for now
                    if (sectionName === "App Config" && key.toLowerCase().includes('color')) continue;

                    const row = document.createElement('div');
                    row.className = 'config-row';

                    const label = document.createElement('label');
                    label.textContent = key + ':';
                    label.htmlFor = `config-${key}`;
                    row.appendChild(label);

                    const input = document.createElement('input');
                    input.id = `config-${key}`;
                    
                    let type = 'text';
                    if (typeof configObject[key] === 'number') type = 'number';
                    else if (typeof configObject[key] === 'boolean') type = 'checkbox';

                    input.type = type;

                    if (type === 'number') {
                        input.step = integerVarsInSection.includes(key) ? '1' : '0.01';
                        input.value = configObject[key];
                    } else if (type === 'checkbox') {
                        input.checked = configObject[key];
                    } else {
                        input.value = configObject[key];
                    }
                    
                    input.dataset.key = key;
                    input.dataset.configSection = sectionName; 
                    row.appendChild(input);

                    configVarsListDiv.appendChild(row);
                }
            }
        }

        configVarsListDiv.addEventListener('change', (event) => {
            if (event.target.tagName === 'INPUT') {
                const key = event.target.dataset.key;
                const sectionName = event.target.dataset.configSection;
                const configObject = configsToDisplay[sectionName].config;
                let value = event.target.type === 'checkbox' ? event.target.checked : event.target.value;

                if (event.target.type === 'number') {
                    value = parseFloat(value);
                }
                
                if (typeof configObject[key] === 'number' && isNaN(value)) {
                    statusP.textContent = `Invalid value for ${key}. Must be a number.`;
                    statusP.style.color = 'red';
                    event.target.value = configObject[key]; 
                    return;
                }

                configObject[key] = value;
                statusP.textContent = `Updated ${key} to ${value}`;
                statusP.style.color = 'lightgreen';
                console.log(`Updated ${sectionName} -> ${key}: ${value}`);
            }
        });
        statusP.textContent = 'Config loaded. You can edit values above.';
        statusP.style.color = 'lightgreen';
    }

    // Main application logic
    const video = document.getElementById('video');
    const overlayCanvas = document.getElementById('overlay');
    const overlayCtx = overlayCanvas.getContext('2d');
    const poseTextEl = document.getElementById('poseText');
    const resetPoseStateButton = document.getElementById('resetPoseStateButton');

    let detector;
    let rafId;

    async function createDetector() {
        const model = poseDetection.SupportedModels.MoveNet;
        // You can choose different model types: 'Lightning', 'Thunder'
        // Lightning is faster, Thunder is more accurate.
        // SinglePose is good for one person. MultiPose for multiple.
        const detectorConfig = {
            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            // enableSmoothing: true // Smoothing is handled by our custom logic now
        };
        return poseDetection.createDetector(model, detectorConfig);
    }

    async function setupCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('Browser API navigator.mediaDevices.getUserMedia not available');
        }
        const stream = await navigator.mediaDevices.getUserMedia({
            'audio': false,
            'video': {
                facingMode: 'user',
                width: video.width,
                height: video.height,
            },
        });
        video.srcObject = stream;

        return new Promise((resolve) => {
            video.onloadedmetadata = () => {
                video.play();
                resolve(video);
            };
        });
    }

    async function poseDetectionLoop() {
        if (detector && video.readyState >= 2) { // Ensure video is ready enough
            let poses = null;
            try {
                poses = await detector.estimatePoses(video, {
                    flipHorizontal: false // Already flipped by CSS
                });
            } catch (error) {
                console.error("Error estimating poses:", error);
                detector.dispose(); // Dispose of the old detector
                console.log("Re-creating detector...");
                detector = await createDetector(); // Re-create detector
            }


            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            if (poses && poses.length > 0 && poses[0] && poses[0].keypoints) {
                const estimatedState = interpretPoseFromModule(poses[0], video.videoWidth, video.videoHeight);
                
                // *** MODIFICATION FOR POSE TEXT COLOR STARTS HERE ***
                if (estimatedState) {
                    poseTextEl.textContent = `Pose: ${estimatedState}`; // POSE_STATES values are strings
                    switch (estimatedState) {
                        case POSE_STATES.PUNCH_BOTH:
                            poseTextEl.style.color = APP_CONFIG.punchBothColor;
                            break;
                        case POSE_STATES.PUNCH_LEFT:
                            poseTextEl.style.color = APP_CONFIG.punchLeftColor;
                            break;
                        case POSE_STATES.PUNCH_RIGHT:
                            poseTextEl.style.color = APP_CONFIG.punchRightColor;
                            break;
                        default:
                            poseTextEl.style.color = APP_CONFIG.defaultPoseTextColor; 
                            break;
                    }
                } else {
                    poseTextEl.textContent = 'Pose: N/A';
                    poseTextEl.style.color = APP_CONFIG.defaultPoseTextColor;
                }
                // *** MODIFICATION FOR POSE TEXT COLOR ENDS HERE ***

                drawKeypoints(overlayCtx, video.videoWidth);
                
                // Update debug values
                const internalState = getPoseDetectionInternalState();
                updateDebugValue('Frame', appState.frameCounter);
                updateDebugValue('Est. State', estimatedState || "N/A");
                updateDebugValue('Standing Nose Y', internalState.standingNoseY ? internalState.standingNoseY.toFixed(2) : "N/A");
                updateDebugValue('Is Ducking', internalState.ducking);
                updateDebugValue('Is Standing Calibrated', internalState.standingHeightCalibrated);
                updateDebugValue('Is Temp Incomplete', internalState.temporarilyIncomplete);

            } else {
                poseTextEl.textContent = 'No pose detected';
                poseTextEl.style.color = APP_CONFIG.defaultPoseTextColor;
                 // Reset some debug values if no pose
                updateDebugValue('Est. State', "No Pose");
            }
        }
        appState.frameCounter++;
        rafId = requestAnimationFrame(poseDetectionLoop);
    }

    async function init() {
        try {
            poseTextEl.textContent = 'Initializing TFJS...';
            await tf.ready();
            console.log('TFJS backend:', tf.getBackend());
            
            poseTextEl.textContent = 'Setting up camera...';
            await setupCamera();
            console.log('Camera setup complete.');
            video.width = video.videoWidth; // Use intrinsic video size
            video.height = video.videoHeight;
            overlayCanvas.width = video.videoWidth;
            overlayCanvas.height = video.videoHeight;


            poseTextEl.textContent = 'Loading PoseNet model...';
            detector = await createDetector();
            console.log('Detector created.');

            setupConfigControls(); // Setup controls after configs are available

            resetPoseStateButton.addEventListener('click', () => {
                resetPoseDetectionState(video.videoHeight); // Pass current video height for context if needed by reset
                console.warn("Pose detection state has been reset.");
                poseTextEl.textContent = "Pose state reset. Recalibrating...";
                poseTextEl.style.color = APP_CONFIG.defaultPoseTextColor;
            });
            
            poseTextEl.textContent = 'Starting detection...';
            poseDetectionLoop();
        } catch (error) {
            console.error("Initialization failed:", error);
            poseTextEl.textContent = `Error: ${error.message}`;
            poseTextEl.style.color = 'red';
        }
    }

    init();

  </script>
</body>
</html>
