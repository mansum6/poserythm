<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pose Detector</title>
<script type="importmap">
{
"imports": {
"@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
"@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
}
}
</script>
<style>
/* ... (CSS remains the same as the previous version) ... */
body, html {
    margin:0;
    padding:0;
    background:#222;
    color:#fff;
    font-family:sans-serif;
    height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent body scrollbars */
}

#app-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
}

/* 1. Pose Info Area (Top 20%) */
#pose-info-area {
    flex: 0 0 20%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background-color: #2a2a2a;
    padding: 5px;
    box-sizing: border-box;
}
#poseText {
    font-size: clamp(1.5rem, 8vh, 4.5rem); /* Responsive font size */
    text-align:center;
    color: #eee;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 2. Video Area (Middle 40%) */
#video-area {
    flex: 0 0 40%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1c1c1c;
    overflow: hidden; /* Important for scaling content */
    padding: 5px; /* Optional padding around video container */
    box-sizing: border-box;
}
#container {
    position:relative;
    aspect-ratio: 640 / 480;
    height: 100%; /* Fill the height of video-area */
    max-width: 100%; /* Don't exceed width of video-area */
    margin:0 auto; /* Center if aspect ratio makes it narrower than area */
    border: 1px solid #444;
    background: #000; /* Background for letter/pillar boxing */
}
#video {
    display: block; /* Remove extra space below video */
    width:100%;
    height:100%;
    transform: scaleX(-1);
    object-fit: contain; /* Show whole frame, scaled down, letter/pillar boxed */
}
#overlay {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
    transform: scaleX(-1); /* Mirrors the canvas drawing space */
}

/* 3. Config Area (Below Middle 35%) */
#config-area {
    flex: 0 0 35%;
    background-color: #252525;
    overflow-y: auto; /* Scroll if content exceeds height */
    padding: 10px;
    box-sizing: border-box;
}
#controlsContainer {
    padding: 10px;
    margin: 0 auto;
    border: 1px solid #555;
    border-radius: 8px;
    background-color: #333;
    color: #fff;
    max-width: 700px; /* Max width for readability */
}
#controlsContainer h3 {
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    color: #0af;
}
#config-vars-list div { /* Each config row */
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    flex-wrap: wrap; /* Wrap on small screens if needed */
    padding: 5px;
    border-bottom: 1px solid #404040;
}
#config-vars-list div:last-child {
    border-bottom: none;
}
#controlsContainer label {
    margin-right: 10px;
    min-width: 260px; /* Adjusted for longer names */
    font-size: 0.9em;
    color: #ccc;
}
#controlsContainer input[type="number"] {
    padding: 6px 8px;
    border: 1px solid #555;
    background-color: #444;
    color: #fff;
    border-radius: 4px;
    width: 100px;
    max-width:120px;
    margin-right: 10px;
}
#controlsContainer button {
    padding: 6px 12px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    margin-left: auto; /* Pushes button to the right if space allows */
}
#controlsContainer button:hover { background-color: #0056b3; }
#configStatus {
    font-size: 0.9em;
    min-height: 1.2em;
    margin-top: 15px;
    text-align: center;
    color: #7f7;
}

/* 4. Console Output Area (Bottom 5%) */
#console-output-area {
    flex: 0 0 5%;
    background-color: #111;
    color: #ccc;
    padding: 8px;
    font-family: monospace;
    font-size: 0.8em;
    overflow-y: auto;
    border-top: 1px solid #444;
    box-sizing: border-box;
}
#console-output-area p {
    margin: 2px 0;
    padding: 0;
    white-space: pre-wrap; /* Allow wrapping but preserve spaces */
}
#console-output-area p.error { color: #ff6b6b; }
#console-output-area p.warn { color: #ffa500; }
#console-output-area p.log { color: #ccc; }
</style>
</head>
<body>

<div id="app-container">
    <div id="pose-info-area">
        <div id="poseText">Loadingâ€¦</div>
    </div>
    <div id="video-area">
        <div id="container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
        </div>
    </div>
    <div id="config-area">
        <div id="controlsContainer">
          <h3>Adjust Configuration</h3>
          <div id="config-vars-list"></div>
          <p id="configStatus"></p>
        </div>
    </div>
    <div id="console-output-area"></div>
</div>

<script type="module">
  import * as tf from '@tensorflow/tfjs';
  import * as poseDetection from '@tensorflow-models/pose-detection';

  const consoleOutputDiv = document.getElementById('console-output-area');
  function logToScreen(message, type = 'log') {
    // ... (logToScreen function remains the same)
    if (!consoleOutputDiv) return;
    const p = document.createElement('p');
    const GTMtimestamp = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'});
    p.textContent = `[${GTMtimestamp} ${type.toUpperCase()}]: ${message}`;
    p.className = type; // for styling (error, warn, log)
    consoleOutputDiv.appendChild(p);
    consoleOutputDiv.scrollTop = consoleOutputDiv.scrollHeight;
  }
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;
  console.log = (...args) => {
    originalConsoleLog.apply(console, args);
    logToScreen(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '), 'log');
  };
  console.error = (...args) => {
    originalConsoleError.apply(console, args);
    logToScreen(args.map(arg => String(arg)).join(' '), 'error');
  };
  console.warn = (...args) => {
    originalConsoleWarn.apply(console, args);
    logToScreen(args.map(arg => String(arg)).join(' '), 'warn');
  };

  // CONFIG & STATE
  const CONFIG = {
    minPoseConfidence: 0.25,    // General minimum confidence for a keypoint to be considered
    poseSmoothFactor: 0.75,     // Smoothing factor for keypoint positions (0-1, higher is smoother)
    minTorsoHeight: 25,        // Min screen pixels for torso to be considered a valid pose
    minShoulderWidth: 25,      // Min screen pixels for shoulder width
    duckThresholdRatio: 0.4,     // Nose must drop this ratio of calibratedTorsoHeight to trigger duck
    leanThresholdX: 0.15,      // Lean offset (shoulder_mid_x - hip_mid_x) must be this ratio of shoulderWidth
    punchThresholdX: 0.3,      // Elbow-wrist X distance must be this ratio of shoulder-elbow X distance for punch
    temporarilyIncompleteDurationMs: 700, // How long a pose can be missing some parts before becoming fully incomplete

    // New/Revised for Duck and Calibration Robustness
    duckShoulderWidthToleranceRatio: 0.25, // Allowed % change in shoulder width during deep duck if hips are lost
    deepDuckNoseDropFactor: 0.55,         // Nose must drop by this factor of calibratedTorsoHeight for deep duck inference
    duckExitFactor: 0.75,                 // To exit duck, nose must rise above (duckThresholdRatio * duckExitFactor)
    minScoreForCalibrationKeypoints: 0.4, // Min score for nose, shoulders, hips to be used in calibration
    recalibrationTorsoChangeThreshold: 0.20, // % change in current torso height (relative to calibrated) to trigger recalibration
  };

  const POSE_STATES = { /* ... (remains the same) ... */
    IDLE: 'IDLE', PUNCH_LEFT: 'PUNCH_LEFT', PUNCH_RIGHT: 'PUNCH_RIGHT', LEAN_LEFT: 'LEAN_LEFT', LEAN_RIGHT: 'LEAN_RIGHT',
    DUCK: 'DUCK', POSE_TEMPORARILY_INCOMPLETE: 'POSE_TEMPORARILY_INCOMPLETE', POSE_INCOMPLETE: 'POSE_INCOMPLETE',
    PUNCH_BOTH: 'PUNCH_BOTH', POSE_LOST: 'POSE_LOST', CALIBRATING: 'CALIBRATING'
  };

  const essentialNames = [
    "nose", "left_shoulder", "right_shoulder",
    "left_hip", "right_hip", "left_wrist",
    "right_wrist", "left_elbow", "right_elbow"
  ];
  const calibrationKeypointNames = ["nose", "left_shoulder", "right_shoulder", "left_hip", "right_hip"];

  const integerConfigVars = ['minTorsoHeight', 'minShoulderWidth', 'temporarilyIncompleteDurationMs'];

  let gameState = {
    smoothedKeypoints: {},
    ducking: false, // True if currently in a duck state
    temporarilyIncompleteEntryTime: 0,
    isProperlyCalibrated: false,
    calibratedStandingNoseY: null,
    calibratedTorsoHeight: null,
    calibratedShoulderWidth: null,
    lastPoseState: POSE_STATES.CALIBRATING, // To detect when IDLE is first achieved for calibration
  };

  function _smoothAndGetKeypoint(name, kpMap) {
    // ... (remains the same, but ensure kpMap uses raw keypoints)
    const kp = kpMap[name];
    if(!kp || kp.score < CONFIG.minPoseConfidence) { // Check confidence here
        delete gameState.smoothedKeypoints[name]; // Remove smoothed if original is lost/bad
        return null;
    }

    let sk = gameState.smoothedKeypoints[name];
    if(!sk || sk.rawScore < CONFIG.minPoseConfidence ) { // Also check if smoothed version was based on previously bad raw
      sk = {x: kp.x, y: kp.y, score: kp.score, rawScore: kp.score}; // Store rawScore for future checks
      gameState.smoothedKeypoints[name] = sk;
      return sk;
    }

    const f = CONFIG.poseSmoothFactor;
    sk.x = f * sk.x + (1-f) * kp.x;
    sk.y = f * sk.y + (1-f) * kp.y;
    sk.score = kp.score; // Smoothed score is the latest raw score
    sk.rawScore = kp.score;
    return sk;
  }

  function _checkPunch(w, e, s, isLeft, shoulderMidY, shoulderWidth) { /* ... (remains the same) ... */
    if(!w || !e || !s) return false;
    const wristAhead = isLeft ? (w.x > e.x && e.x > s.x) : (w.x < e.x && e.x < s.x);
    if(!wristAhead) return false;
    const seDist = Math.abs(s.x - e.x),
          ewDist = Math.abs(e.x - w.x),
          alignedY = Math.abs(w.y - shoulderMidY) < shoulderWidth * 0.6;
    return seDist > 5 && ewDist > CONFIG.punchThresholdX * seDist && alignedY;
  }


  function calibrateStandingPose(sKp) { // sKp are smoothed keypoint objects
    if (!sKp.nose || !sKp.ls || !sKp.rs || !sKp.lh || !sKp.rh) {
        console.warn("Calibration skipped: Missing essential keypoints for calibration.");
        return false;
    }

    // Check scores of raw keypoints used for calibration
    const calibMinScore = CONFIG.minScoreForCalibrationKeypoints;
    if (sKp.nose.rawScore < calibMinScore || sKp.ls.rawScore < calibMinScore || sKp.rs.rawScore < calibMinScore ||
        sKp.lh.rawScore < calibMinScore || sKp.rh.rawScore < calibMinScore) {
        console.warn(`Calibration skipped: Keypoint scores too low. N:${sKp.nose.rawScore?.toFixed(2)} LS:${sKp.ls.rawScore?.toFixed(2)} RS:${sKp.rs.rawScore?.toFixed(2)} LH:${sKp.lh.rawScore?.toFixed(2)} RH:${sKp.rh.rawScore?.toFixed(2)}`);
        return false;
    }

    const shoulderMidY = (sKp.ls.y + sKp.rs.y) / 2;
    const hipMidY = (sKp.lh.y + sKp.rh.y) / 2;

    gameState.calibratedStandingNoseY = sKp.nose.y;
    gameState.calibratedTorsoHeight = Math.abs(shoulderMidY - hipMidY);
    gameState.calibratedShoulderWidth = Math.abs(sKp.ls.x - sKp.rs.x);
    gameState.isProperlyCalibrated = true;
    gameState.ducking = false; // Always reset ducking on recalibration

    console.log(`Pose Recalibrated: NoseY=${gameState.calibratedStandingNoseY.toFixed(0)}, TorsoH=${gameState.calibratedTorsoHeight.toFixed(0)}, ShoulderW=${gameState.calibratedShoulderWidth.toFixed(0)}`);
    return true;
  }

function interpretPose(rawKeypoints) {
    if (!rawKeypoints || rawKeypoints.length === 0) {
        gameState.temporarilyIncompleteEntryTime = 0; // Reset timer
        gameState.isProperlyCalibrated = false; // Lose calibration if pose is lost
        return POSE_STATES.POSE_LOST;
    }

    const kpMap = Object.fromEntries(rawKeypoints.map(p => [p.name, p]));

    // Smoothed Keypoints (sKp)
    const sKp = {};
    essentialNames.forEach(name => {
        sKp[name] = _smoothAndGetKeypoint(name, kpMap);
    });

    const { nose, left_shoulder: ls, right_shoulder: rs, left_hip: lh, right_hip: rh,
            left_elbow: le, right_elbow: re, left_wrist: lw, right_wrist: rw } = sKp;

    // --- Calibration Logic ---
    let needsRecalibration = false;
    let canCalibrateNow = nose && ls && rs && lh && rh; // Check if smoothed versions are available

    if (canCalibrateNow) {
        const currentTorsoHeight = Math.abs(((ls.y + rs.y) / 2) - ((lh.y + rh.y) / 2));
        if (!gameState.isProperlyCalibrated) {
            // Try initial calibration if system just started or lost calibration
            // Let's require an IDLE state for initial calibration to avoid calibrating mid-action.
            // This check will be done after state determination.
            needsRecalibration = true; // Flag for potential calibration
        } else {
            // Check if existing calibration is stale due to distance change
            if (gameState.calibratedTorsoHeight > 0 && // Avoid division by zero
                Math.abs(currentTorsoHeight - gameState.calibratedTorsoHeight) / gameState.calibratedTorsoHeight > CONFIG.recalibrationTorsoChangeThreshold) {
                console.log("Recalibration triggered by torso height change.");
                needsRecalibration = true;
            }
        }
        if (needsRecalibration) {
            if (calibrateStandingPose(sKp)) { // Pass smoothed keypoints
                 // Successfully recalibrated
            } else {
                 canCalibrateNow = false; // Calibration failed, likely due to low scores
                 needsRecalibration = false; // Reset flag
            }
        }
    }


    // --- Handle Truly Lost or Minimal Poses ---
    if (!nose || !ls || !rs) { // Absolute minimum: nose and shoulders
        gameState.isProperlyCalibrated = false; // Lose calibration
        // Simplified incomplete logic for now
        if (gameState.temporarilyIncompleteEntryTime === 0) gameState.temporarilyIncompleteEntryTime = performance.now();
        if (performance.now() - gameState.temporarilyIncompleteEntryTime < CONFIG.temporarilyIncompleteDurationMs) {
            return POSE_STATES.POSE_TEMPORARILY_INCOMPLETE;
        }
        return POSE_STATES.POSE_INCOMPLETE; // Or POSE_LOST if more stringent
    }

    // --- Duck Detection ---
    let determinedPose = null; // Will hold the pose if decided early (e.g. DUCK)

    if (gameState.isProperlyCalibrated) {
        const currentShoulderWidth = ls && rs ? Math.abs(ls.x - rs.x) : 0;
        const effectiveNoseDropRatio = gameState.calibratedTorsoHeight > 0 ?
                                     (nose.y - gameState.calibratedStandingNoseY) / gameState.calibratedTorsoHeight : 0;

        // 1. Deep Duck Inference (can override missing hips/wrists)
        if (le && re && // Elbows are important for deep duck orientation
            currentShoulderWidth > 0 && Math.abs(currentShoulderWidth - gameState.calibratedShoulderWidth) <= gameState.calibratedShoulderWidth * CONFIG.duckShoulderWidthToleranceRatio &&
            effectiveNoseDropRatio > CONFIG.deepDuckNoseDropFactor)
        {
            gameState.ducking = true;
            determinedPose = POSE_STATES.DUCK;
            // console.log("Deep DUCK inferred.");
        }
        // 2. Standard Duck (requires all keypoints if not deep duck)
        else if (lh && rh && le && re && lw && rw) { // All essentials needed for standard evaluation
            if (!gameState.ducking && effectiveNoseDropRatio > CONFIG.duckThresholdRatio) {
                gameState.ducking = true;
                // console.log("Standard DUCK entered.");
            } else if (gameState.ducking && effectiveNoseDropRatio < CONFIG.duckThresholdRatio * CONFIG.duckExitFactor) {
                gameState.ducking = false;
                console.log("Standard DUCK exited, recalibrating.");
                // Recalibrate on exiting duck, as user might be in a new standing position
                if(canCalibrateNow) calibrateStandingPose(sKp); // sKp contains all required points for calib here
            }
        }
        // If still ducking after checks, this is the pose
        if (gameState.ducking && !determinedPose) {
             determinedPose = POSE_STATES.DUCK;
        }
    }

    if (determinedPose === POSE_STATES.DUCK) {
        gameState.temporarilyIncompleteEntryTime = 0; // Reset timer if a valid pose (DUCK) is found
        return POSE_STATES.DUCK;
    }


    // --- Full Pose Check for Other Poses (if not ducking) ---
    // All essential keypoints must be present for any other pose.
    const allEssentialsPresent = nose && ls && rs && lh && rh && le && re && lw && rw;

    if (!allEssentialsPresent) {
        if (gameState.temporarilyIncompleteEntryTime === 0) gameState.temporarilyIncompleteEntryTime = performance.now();
        if (performance.now() - gameState.temporarilyIncompleteEntryTime < CONFIG.temporarilyIncompleteDurationMs) {
            return POSE_STATES.POSE_TEMPORARILY_INCOMPLETE;
        }
        gameState.isProperlyCalibrated = false; // If incomplete for too long, lose calibration
        return POSE_STATES.POSE_INCOMPLETE;
    }

    // If we reach here, all essential keypoints are present, and we are not ducking.
    gameState.temporarilyIncompleteEntryTime = 0; // Reset incomplete timer

    // Initial Calibration on first stable IDLE-like pose
    if (!gameState.isProperlyCalibrated && canCalibrateNow) { // canCalibrateNow implies nose, shoulders, hips are good
        console.log("Attempting initial calibration on stable pose.");
        calibrateStandingPose(sKp);
        if(gameState.isProperlyCalibrated) return POSE_STATES.IDLE; // Return IDLE for one frame post-calibration
        else return POSE_STATES.CALIBRATING; // Still waiting for good calib
    }
    if (!gameState.isProperlyCalibrated) return POSE_STATES.CALIBRATING;


    // Recalculate some metrics with all smoothed keypoints assured
    const shoulderMidY = (ls.y + rs.y) / 2;
    const shoulderMidX = (ls.x + rs.x) / 2;
    const hipMidY = (lh.y + rh.y) / 2;
    const hipMidX = (lh.x + rh.x) / 2;
    const currentTorsoHeight = Math.abs(shoulderMidY - hipMidY);
    const currentShoulderWidth = Math.abs(ls.x - rs.x);

    if (currentTorsoHeight < CONFIG.minTorsoHeight || currentShoulderWidth < CONFIG.minShoulderWidth) {
        // This check seems redundant if calibration is working, but good as a fallback
        // console.warn("Pose lost due to min height/width fail after other checks.");
        return POSE_STATES.POSE_LOST; // Or INCOMPLETE
    }

    // --- Lean & Punch Logic ---
    const leanOffset = shoulderMidX - hipMidX;
    const leanThresh = CONFIG.leanThresholdX * currentShoulderWidth;

    if (leanOffset > leanThresh) return POSE_STATES.LEAN_LEFT;
    if (leanOffset < -leanThresh) return POSE_STATES.LEAN_RIGHT;

    const leftPunch = _checkPunch(lw, le, ls, true, shoulderMidY, currentShoulderWidth);
    const rightPunch = _checkPunch(rw, re, rs, false, shoulderMidY, currentShoulderWidth);

    if (leftPunch && rightPunch) return POSE_STATES.PUNCH_BOTH;
    if (leftPunch) return POSE_STATES.PUNCH_LEFT;
    if (rightPunch) return POSE_STATES.PUNCH_RIGHT;

    return POSE_STATES.IDLE;
}


  function drawKeypoints(ctx) { /* ... (remains the same, ensure it uses gameState.smoothedKeypoints) ... */
    ctx.fillStyle = 'lime';
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth = 2;

    essentialNames.forEach(name => {
        const kp = gameState.smoothedKeypoints[name];
        // Ensure kp exists and has a score (smoothedKeypoints might persist even if raw kp is momentarily lost by _smoothAndGetKeypoint logic)
        if (kp && kp.score >= CONFIG.minPoseConfidence) {
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
    });
  }

  function setupConfigControls() { /* ... (remains largely the same, just ensure new CONFIG vars are populated) ... */
    const configVarsListDiv = document.getElementById('config-vars-list');
    const statusP = document.getElementById('configStatus');
    configVarsListDiv.innerHTML = ''; // Clear previous

    Object.entries(CONFIG).forEach(([varName, currentValue]) => {
        const varRowDiv = document.createElement('div');
        const label = document.createElement('label');
        label.htmlFor = `config_input_${varName}`;
        label.textContent = `${varName}:`;
        varRowDiv.appendChild(label);

        const input = document.createElement('input');
        input.type = 'number';
        input.id = `config_input_${varName}`;
        input.value = currentValue;

        if (integerConfigVars.includes(varName)) {
            input.step = "1";
        } else { // Floats
             if (varName.includes('Factor') || varName.includes('Ratio') || varName.includes('Threshold') || varName.includes('Confidence') || varName.includes('Score')) {
                input.step = "0.01"; // Finer step for ratios/factors/thresholds
            } else {
                input.step = "0.1";
            }
        }
        varRowDiv.appendChild(input);

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Update';
        applyBtn.dataset.varname = varName;
        varRowDiv.appendChild(applyBtn);

        applyBtn.addEventListener('click', () => {
            const selectedVar = varName;
            const newValueStr = input.value;
            let newValue;

            if (integerConfigVars.includes(selectedVar)) {
                newValue = parseInt(newValueStr, 10);
            } else {
                newValue = parseFloat(newValueStr);
            }

            if (isNaN(newValue)) {
                statusP.textContent = `Error: Invalid number for ${selectedVar}.`;
                statusP.style.color = '#ff6b6b';
                input.value = CONFIG[selectedVar];
                return;
            }
            // Basic validation for ratios/factors to be between 0 and 1 if applicable
            if ((selectedVar.includes('Factor') || selectedVar.includes('Ratio')) && (selectedVar !== 'deepDuckNoseDropFactor' && selectedVar !== 'duckThresholdRatio') && (newValue < 0 || newValue > 1)) {
                 // Allow duckThresholdRatio and deepDuckNoseDropFactor to be > 1 theoretically, though practically they won't be.
                if (selectedVar !== 'duckThresholdRatio' && selectedVar !== 'deepDuckNoseDropFactor' && selectedVar !== 'leanThresholdX' && selectedVar !== 'punchThresholdX') {
                   // console.warn(`${selectedVar} is typically 0-1. Value: ${newValue}`);
                }
            }


            CONFIG[selectedVar] = newValue;
            input.value = newValue;
            statusP.textContent = `${selectedVar} updated to ${CONFIG[selectedVar]}.`;
            statusP.style.color = '#7f7';
            console.log('CONFIG updated:', JSON.parse(JSON.stringify(CONFIG)));

            // If a calibration-related parameter changed, it might be good to force a recalibration
            if (selectedVar.includes('ScoreForCalibrationKeypoints') || selectedVar.includes('recalibrationTorsoChangeThreshold')) {
                gameState.isProperlyCalibrated = false; // Force recalibration check on next frame
                console.log("Calibration parameter changed, forcing recalibration check.");
            }
        });
        configVarsListDiv.appendChild(varRowDiv);
    });
    statusP.textContent = 'Config loaded. Adjust values and click "Update".';
  }


  async function main() {
    await tf.setBackend('webgl');
    await tf.ready();
    console.log('TF backend:', tf.getBackend());

    const video = document.getElementById('video'),
          canvas = document.getElementById('overlay'),
          ctx = canvas.getContext('2d'),
          poseTextEl = document.getElementById('poseText');

    setupConfigControls();

    const stream = await navigator.mediaDevices.getUserMedia({video: {width: 640, height: 480}});
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    video.play().catch(e => {
        console.error("Video play failed:", e);
        logToScreen("Video play failed. User interaction might be needed.", "error");
    });

    const detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING}
    );

    poseTextEl.innerText = 'CALIBRATING'; // Initial state

    async function frameLoop() {
      if (video.readyState < video.HAVE_METADATA || video.paused || video.ended) {
          requestAnimationFrame(frameLoop);
          return;
      }
      if (canvas.width !== video.clientWidth || canvas.height !== video.clientHeight) {
          canvas.width = video.clientWidth;
          canvas.height = video.clientHeight;
      }

      const poses = await detector.estimatePoses(video, {flipHorizontal: false});
      const estimatedState = interpretPose(poses[0]?.keypoints || []);

      // Update displayed pose text, but don't show POSE_TEMPORARILY_INCOMPLETE
      // to avoid flickering if it's very short.
      if (estimatedState !== POSE_STATES.POSE_TEMPORARILY_INCOMPLETE) {
        poseTextEl.innerText = estimatedState;
      }
      gameState.lastPoseState = estimatedState; // Store for next frame logic (e.g. initial calib)


      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (poses[0]?.keypoints && video.videoWidth > 0 && video.videoHeight > 0) {
          ctx.save();
          const videoAspectRatio = video.videoWidth / video.videoHeight;
          const canvasAspectRatio = canvas.width / canvas.height;
          let renderWidth, renderHeight, offsetX = 0, offsetY = 0;
          if (videoAspectRatio > canvasAspectRatio) {
              renderWidth = canvas.width;
              renderHeight = renderWidth / videoAspectRatio;
              offsetY = (canvas.height - renderHeight) / 2;
          } else {
              renderHeight = canvas.height;
              renderWidth = renderHeight * videoAspectRatio;
              offsetX = (canvas.width - renderWidth) / 2;
          }
          ctx.translate(offsetX, offsetY);
          ctx.scale(renderWidth / video.videoWidth, renderHeight / video.videoHeight);
          drawKeypoints(ctx);
          ctx.restore();
      }
      requestAnimationFrame(frameLoop);
    }
    frameLoop();
  }

  main().catch(e => {
    console.error(e);
    document.getElementById('poseText').innerText = 'Critical Error!';
  });
  </script>
</body>
</html>
