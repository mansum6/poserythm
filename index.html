<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pose Detector</title>
  <script type="importmap">
  {
    "imports": {
      "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
      "@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
    }
  }
  </script>
  <style>
    body, html { margin:0; padding:0; background:#222; color:#fff; font-family:sans-serif; }
    #poseText { font-size:4.5rem; text-align:center; padding:10px; }
    #container { position:relative; width:640px; margin:0 auto; }
    #video { width:100%; transform: scaleX(-1); }
    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; transform: scaleX(-1); }
  </style>
</head>
<body>
  <div id="poseText">Loading…</div>
  <div id="container">
    <video id="video" autoplay playsinline></video>
    <canvas id="overlay"></canvas>
  </div>

  <script type="module">
  import * as tf from '@tensorflow/tfjs';
  import * as poseDetection from '@tensorflow-models/pose-detection';

  // CONFIG & STATE (unchanged) …
  const CONFIG = {
    minPoseConfidence: 0.3, poseSmoothFactor: 0.8,
    minTorsoHeight: 30, minShoulderWidth: 30,
    torsoChangeThreshold: 0.2, duckThresholdRatio: 1.75,
    leanThresholdX: 0.15, punchThresholdX: 0.3,
  };
  const POSE_STATES = {
    IDLE:'IDLE', PUNCH_LEFT:'PUNCH_LEFT', PUNCH_RIGHT:'PUNCH_RIGHT',
    LEAN_LEFT:'LEAN_LEFT', LEAN_RIGHT:'LEAN_RIGHT', DUCK:'DUCK',
    POSE_INCOMPLETE:'POSE_INCOMPLETE', PUNCH_BOTH:'PUNCH_BOTH', POSE_LOST:'POSE_LOST'
  };
  const essentialNames = ["nose","left_shoulder","right_shoulder","left_hip","right_hip","left_wrist","right_wrist","left_elbow","right_elbow"];
  let gameState = { smoothedKeypoints:{}, lastTorsoHeight:null, standingNoseY:null, ducking:false };

  function _smoothAndGetKeypoint(name, map) {
    const kp = map[name]; if(!kp) return null;
    let sk = gameState.smoothedKeypoints[name];
    if(!sk){ sk={x:kp.x,y:kp.y,score:kp.score}; gameState.smoothedKeypoints[name]=sk; return sk; }
    const f=CONFIG.poseSmoothFactor;
    sk.x=f*sk.x+(1-f)*kp.x; sk.y=f*sk.y+(1-f)*kp.y; sk.score=kp.score;
    return sk;
  }
  function _checkPunch(w,e,s,isLeft,shoulderMidY,shoulderWidth){
    if(!w||!e||!s) return false;
    const wristAhead = isLeft ? (w.x > e.x && e.x > s.x) : (w.x < e.x && e.x < s.x);
    if(!wristAhead) return false;
    const seDist=Math.abs(s.x - e.x), ewDist=Math.abs(e.x - w.x),
          alignedY=Math.abs(w.y - shoulderMidY) < shoulderWidth*0.6;
    return seDist>5 && ewDist>CONFIG.punchThresholdX*seDist && alignedY;
  }
  function interpretPose(keypoints) {
    if(!keypoints||keypoints.length===0) return POSE_STATES.POSE_LOST;
    const kpMap = Object.fromEntries(
      keypoints.filter(p=>p.name&&p.score>=CONFIG.minPoseConfidence)
               .map(p=>[p.name,p])
    );
    const present=essentialNames.filter(n=>kpMap[n]);
    if(present.length===0) return POSE_STATES.POSE_LOST;
    if(present.length<essentialNames.length) return POSE_STATES.POSE_INCOMPLETE;

    const es={};
    for(let n of essentialNames) es[n]=_smoothAndGetKeypoint(n,kpMap);
    const {nose, left_shoulder:ls, right_shoulder:rs, left_hip:lh, right_hip:rh,
           left_wrist:lw, right_wrist:rw, left_elbow:le, right_elbow:re}=es;

    const shoulderMidY=(ls.y+rs.y)/2, shoulderMidX=(ls.x+rs.x)/2,
          hipMidY=(lh.y+rh.y)/2, hipMidX=(lh.x+rh.x)/2,
          torsoHeight=Math.abs(shoulderMidY-hipMidY),
          shoulderWidth=Math.abs(ls.x-rs.x);

    if(torsoHeight<CONFIG.minTorsoHeight||shoulderWidth<CONFIG.minShoulderWidth)
      return POSE_STATES.POSE_LOST;

    if(gameState.lastTorsoHeight!=null &&
       Math.abs(torsoHeight-gameState.lastTorsoHeight)/gameState.lastTorsoHeight>CONFIG.torsoChangeThreshold){
      gameState.standingNoseY=nose.y;
    }
    gameState.lastTorsoHeight=torsoHeight;
    if(!gameState.standingNoseY) gameState.standingNoseY=nose.y;

    const normalizedDrop=(nose.y-gameState.standingNoseY)/torsoHeight;
    if(!gameState.ducking && normalizedDrop>CONFIG.duckThresholdRatio){
      gameState.ducking=true; return POSE_STATES.DUCK;
    }
    if(gameState.ducking && normalizedDrop<CONFIG.duckThresholdRatio*0.5){
      gameState.ducking=false;
    }
    if(gameState.ducking) return POSE_STATES.DUCK;

    const leanOffset=shoulderMidX-hipMidX, leanThresh=CONFIG.leanThresholdX*shoulderWidth;
    if(leanOffset>leanThresh) return POSE_STATES.LEAN_LEFT;
    if(leanOffset< -leanThresh) return POSE_STATES.LEAN_RIGHT;

    const leftPunch=_checkPunch(lw,le,ls,true,shoulderMidY,shoulderWidth),
          rightPunch=_checkPunch(rw,re,rs,false,shoulderMidY,shoulderWidth);
    if(leftPunch&&rightPunch) return POSE_STATES.PUNCH_BOTH;
    if(leftPunch) return POSE_STATES.PUNCH_LEFT;
    if(rightPunch) return POSE_STATES.PUNCH_RIGHT;

    return POSE_STATES.IDLE;
  }

  function drawKeypoints(ctx) {
    ctx.fillStyle='lime'; ctx.strokeStyle='yellow'; ctx.lineWidth=2;
    for(let n of essentialNames){
      const kp=gameState.smoothedKeypoints[n];
      if(!kp||kp.score<CONFIG.minPoseConfidence) continue;
      ctx.beginPath();
      ctx.arc(kp.x,kp.y,5,0,2*Math.PI);
      ctx.fill(); ctx.stroke();
    }
  }

  async function main(){
    // <-- ensure TF backend is ready:
    await tf.setBackend('webgl'); 
    await tf.ready();
    console.log('TF backend:', tf.getBackend());

    const video=document.getElementById('video'),
          canvas=document.getElementById('overlay'),
          ctx=canvas.getContext('2d'),
          poseText=document.getElementById('poseText');

    const stream=await navigator.mediaDevices.getUserMedia({video:{width:640,height:480}});
    video.srcObject=stream;
    await new Promise(r=>video.onloadedmetadata=r);
    video.play();

    canvas.width=video.videoWidth;
    canvas.height=video.videoHeight;

    const detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING}
    );
    poseText.innerText='Ready!';

    async function frameLoop(){
      const poses = await detector.estimatePoses(video);
      const state = interpretPose(poses[0]?.keypoints||[]);
      poseText.innerText = state;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawKeypoints(ctx);
      requestAnimationFrame(frameLoop);
    }
    frameLoop();
  }

  main().catch(e=>{
    console.error(e);
    document.getElementById('poseText').innerText = 'Error: '+e.message;
  });
  </script>
</body>
</html>
