<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pose Detector</title>
<script type="importmap">
{
"imports": {
"@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
"@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
}
}
</script>
<style>
body, html {
    margin:0;
    padding:0;
    background:#222;
    color:#fff;
    font-family:sans-serif;
    height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent body scrollbars */
}

#app-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
}

/* 1. Pose Info Area (Top 20%) */
#pose-info-area {
    flex: 0 0 20%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    background-color: #2a2a2a;
    padding: 5px;
    box-sizing: border-box;
}
#poseText {
    font-size: clamp(1.5rem, 8vh, 4.5rem); /* Responsive font size */
    text-align:center;
    color: #eee;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 2. Video Area (Middle 40%) */
#video-area {
    flex: 0 0 40%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1c1c1c;
    overflow: hidden; /* Important for scaling content */
    padding: 5px; /* Optional padding around video container */
    box-sizing: border-box;
}
#container {
    position:relative;
    aspect-ratio: 640 / 480;
    height: 100%;
    max-width: 100%;
    margin:0 auto;
    border: 1px solid #444;
    background: #000;
}
#video {
    display: block;
    width:100%;
    height:100%;
    transform: scaleX(-1);
    object-fit: contain;
}
#overlay {
    position:absolute;
    top:0;
    left:0;
    width:100%;
    height:100%;
    pointer-events:none;
    transform: scaleX(-1);
}

/* 3. Config Area (Below Middle 35%) */
#config-area {
    flex: 0 0 35%;
    background-color: #252525;
    overflow-y: auto;
    padding: 10px;
    box-sizing: border-box;
}
#controlsContainer {
    padding: 10px;
    margin: 0 auto;
    border: 1px solid #555;
    border-radius: 8px;
    background-color: #333;
    color: #fff;
    max-width: 700px;
}
#controlsContainer h3 {
    margin-top: 0;
    margin-bottom: 15px;
    text-align: center;
    color: #0af;
}
#config-vars-list div {
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    padding: 5px;
    border-bottom: 1px solid #404040;
}
#config-vars-list div:last-child {
    border-bottom: none;
}
#controlsContainer label {
    margin-right: 10px;
    min-width: 280px; /* Adjusted for longer new var names */
    font-size: 0.9em;
    color: #ccc;
}
#controlsContainer input[type="number"] {
    padding: 6px 8px;
    border: 1px solid #555;
    background-color: #444;
    color: #fff;
    border-radius: 4px;
    width: 100px;
    max-width:120px;
    margin-right: 10px;
}
#controlsContainer button {
    padding: 6px 12px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9em;
    margin-left: auto;
}
#controlsContainer button:hover { background-color: #0056b3; }
#configStatus {
    font-size: 0.9em;
    min-height: 1.2em;
    margin-top: 15px;
    text-align: center;
    color: #7f7;
}

/* 4. Console Output Area (Bottom 5%) */
#console-output-area {
    flex: 0 0 5%;
    background-color: #111;
    color: #ccc;
    padding: 8px;
    font-family: monospace;
    font-size: 0.8em;
    overflow-y: auto;
    border-top: 1px solid #444;
    box-sizing: border-box;
}
#console-output-area p {
    margin: 2px 0;
    padding: 0;
    white-space: pre-wrap;
}
#console-output-area p.error { color: #ff6b6b; }
#console-output-area p.warn { color: #ffa500; }
#console-output-area p.log { color: #ccc; }
</style>
</head>
<body>

<div id="app-container">
    <div id="pose-info-area">
        <div id="poseText">Loadingâ€¦</div>
    </div>

    <div id="video-area">
        <div id="container">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="overlay"></canvas>
        </div>
    </div>

    <div id="config-area">
        <div id="controlsContainer">
          <h3>Adjust Configuration</h3>
          <div id="config-vars-list"></div>
          <p id="configStatus"></p>
        </div>
    </div>

    <div id="console-output-area"></div>
</div>

<script type="module">
  import * as tf from '@tensorflow/tfjs';
  import * as poseDetection from '@tensorflow-models/pose-detection';

  const consoleOutputDiv = document.getElementById('console-output-area');

  function logToScreen(message, type = 'log') {
    if (!consoleOutputDiv) return;
    const p = document.createElement('p');
    const GTMtimestamp = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit'});
    p.textContent = `[${GTMtimestamp} ${type.toUpperCase()}]: ${message}`;
    p.className = type;
    consoleOutputDiv.appendChild(p);
    consoleOutputDiv.scrollTop = consoleOutputDiv.scrollHeight;
  }

  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;

  console.log = (...args) => {
    originalConsoleLog.apply(console, args);
    logToScreen(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : String(arg)).join(' '), 'log');
  };
  console.error = (...args) => {
    originalConsoleError.apply(console, args);
    logToScreen(args.map(arg => String(arg)).join(' '), 'error');
  };
  console.warn = (...args) => {
    originalConsoleWarn.apply(console, args);
    logToScreen(args.map(arg => String(arg)).join(' '), 'warn');
  };

  const CONFIG = {
    minPoseConfidence: 0.3,
    poseSmoothFactor: 0.8,
    minTorsoHeight: 30,
    minShoulderWidth: 30,
    torsoChangeThreshold: 0.05,
    duckThresholdRatio: 0.7, // Adjusted default: nose must drop 70% of standingTorsoHeight
    duckExitFactor: 0.6,     // Exit duck if drop is < (duckThresholdRatio * duckExitFactor)
    leanThresholdX: 0.15,
    punchThresholdX: 0.3,
    temporarilyIncompleteDurationMs: 500,
    shoulderWidthToleranceForDuckOcclusion: 0.15, // 15% tolerance
  };

  const POSE_STATES = { /* ... (same as before) ... */
    IDLE: 'IDLE', PUNCH_LEFT: 'PUNCH_LEFT', PUNCH_RIGHT: 'PUNCH_RIGHT', LEAN_LEFT: 'LEAN_LEFT',
    LEAN_RIGHT: 'LEAN_RIGHT', DUCK: 'DUCK', POSE_TEMPORARILY_INCOMPLETE: 'POSE_TEMPORARILY_INCOMPLETE',
    POSE_INCOMPLETE: 'POSE_INCOMPLETE', PUNCH_BOTH: 'PUNCH_BOTH', POSE_LOST: 'POSE_LOST'
  };

  const essentialNames = [
    "nose", "left_shoulder", "right_shoulder",
    "left_hip", "right_hip", "left_wrist",
    "right_wrist", "left_elbow", "right_elbow"
  ];
  const essentialNamesForDuckOcclusion = [ // When hips/wrists can be occluded
    "nose", "left_shoulder", "right_shoulder", "left_elbow", "right_elbow"
  ];

  const integerConfigVars = ['minTorsoHeight', 'minShoulderWidth', 'temporarilyIncompleteDurationMs'];

  let gameState = {
    smoothedKeypoints: {},
    lastTorsoHeight: null,        // Stores the actual torso height from the last frame (if hips were visible)
    standingNoseY: null,          // Y-coordinate of the nose when standing
    standingTorsoHeight: null,    // Torso height when standing (shoulder_mid_y - hip_mid_y)
    standingShoulderWidth: null,  // Shoulder width when standing
    ducking: false,
    temporarilyIncompleteEntryTime: 0,
  };

  function _smoothAndGetKeypoint(name, map) {
    const kp = map[name];
    if(!kp) return null;

    let sk = gameState.smoothedKeypoints[name];
    if(!sk || sk.name !== name) { // Ensure re-initialization if name changes (defensive)
      sk = {x: kp.x, y: kp.y, score: kp.score, name: name};
      gameState.smoothedKeypoints[name] = sk;
      return sk;
    }

    const f = CONFIG.poseSmoothFactor;
    sk.x = f * sk.x + (1-f) * kp.x;
    sk.y = f * sk.y + (1-f) * kp.y;
    sk.score = kp.score; // Use latest score
    return sk;
  }

  function _checkPunch(w, e, s, isLeft, shoulderMidY, shoulderWidth) {
    if(!w || !e || !s) return false;
    const wristAhead = isLeft ? (w.x > e.x && e.x > s.x) : (w.x < e.x && e.x < s.x);
    if(!wristAhead) return false;
    const seDist = Math.abs(s.x - e.x);
    const ewDist = Math.abs(e.x - w.x);
    const alignedY = Math.abs(w.y - shoulderMidY) < shoulderWidth * 0.6;
    return seDist > 5 && ewDist > CONFIG.punchThresholdX * seDist && alignedY;
  }

  function interpretPose(keypoints) {
    if (!keypoints || keypoints.length === 0) {
      gameState.temporarilyIncompleteEntryTime = 0;
      gameState.ducking = false; // Ensure ducking state is reset if pose is lost
      return POSE_STATES.POSE_LOST;
    }

    const kpMap = Object.fromEntries(
      keypoints.filter(p => p.name && p.score >= CONFIG.minPoseConfidence)
               .map(p => [p.name, p])
    );

    // --- Determine if hip/wrist occlusion is allowed for THIS frame ---
    let allowHipWristOcclusion = false;
    const rawNose = kpMap["nose"];
    const rawLS = kpMap["left_shoulder"];
    const rawRS = kpMap["right_shoulder"];

    if (rawNose && rawLS && rawRS && gameState.standingShoulderWidth > 0 && gameState.standingTorsoHeight > 0) {
        const currentRawShoulderWidth = Math.abs(rawLS.x - rawRS.x);
        let potentialDuckThisFrame = false;
        if (gameState.standingNoseY) { // Check only if standingNoseY is set
            const actualDropPixels = rawNose.y - gameState.standingNoseY;
            const normalizedDrop = actualDropPixels / gameState.standingTorsoHeight; // Use standingTorsoHeight
            // Consider potential duck if nose drops significantly (e.g., 80% of threshold for entry)
            if (normalizedDrop > CONFIG.duckThresholdRatio * 0.8) {
                potentialDuckThisFrame = true;
            }
        }

        if ((gameState.ducking || potentialDuckThisFrame) &&
            Math.abs(currentRawShoulderWidth - gameState.standingShoulderWidth) / gameState.standingShoulderWidth < CONFIG.shoulderWidthToleranceForDuckOcclusion) {
            allowHipWristOcclusion = true;
        }
    }
    // --- End Occlusion Check ---

    const currentEssentialNames = allowHipWristOcclusion ? essentialNamesForDuckOcclusion : essentialNames;
    const essentialKeypointsPresent = currentEssentialNames.every(n => kpMap[n]);

    if (!essentialKeypointsPresent) {
      if (gameState.temporarilyIncompleteEntryTime === 0) {
        gameState.temporarilyIncompleteEntryTime = performance.now();
        return POSE_STATES.POSE_TEMPORARILY_INCOMPLETE;
      } else {
        if (performance.now() - gameState.temporarilyIncompleteEntryTime < CONFIG.temporarilyIncompleteDurationMs) {
          return POSE_STATES.POSE_TEMPORARILY_INCOMPLETE;
        } else {
          if (gameState.ducking && allowHipWristOcclusion) {
             // If we were ducking and allowing occlusion, but core duck KPs are now missing,
             // it's a more serious incompletion. Force exit duck.
             console.warn("Core duck keypoints lost despite allowing occlusion. Exiting duck.");
             gameState.ducking = false;
          }
          return POSE_STATES.POSE_INCOMPLETE;
        }
      }
    }
    gameState.temporarilyIncompleteEntryTime = 0;

    // Smooth ALL potentially needed keypoints if they exist in kpMap
    const es = {}; // Smoothed keypoints
    essentialNames.forEach(name => { // Iterate over the full list
        if (kpMap[name]) {
            es[name] = _smoothAndGetKeypoint(name, kpMap[name]); // Pass kpMap[name] which is the keypoint object
        } else {
            es[name] = null; // Explicitly null if not in kpMap
        }
    });


    const { nose, left_shoulder: ls, right_shoulder: rs,
            left_hip: lh, right_hip: rh,
            left_wrist: lw, right_wrist: rw,
            left_elbow: le, right_elbow: re } = es;

    // Critical keypoints for ANY pose (nose, shoulders, elbows must be smoothed and available if we passed essential check)
    if (!nose || !ls || !rs || !le || !re) {
        console.warn("Critical smoothed keypoints (nose, shoulders, elbows) missing. Incomplete.");
        if(gameState.ducking) gameState.ducking = false; // Safety reset
        return POSE_STATES.POSE_INCOMPLETE;
    }

    const smoothedShoulderWidth = Math.abs(ls.x - rs.x);
    if (smoothedShoulderWidth < CONFIG.minShoulderWidth) {
        console.warn("Smoothed shoulder width too small. POSE_LOST.");
        if(gameState.ducking) gameState.ducking = false;
        return POSE_STATES.POSE_LOST;
    }

    let currentActualSmoothedTorsoHeight = null;
    if (lh && rh) { // Hips are visible and smoothed
        const shoulderMidY_s = (ls.y + rs.y) / 2;
        const hipMidY_s = (lh.y + rh.y) / 2;
        currentActualSmoothedTorsoHeight = Math.abs(shoulderMidY_s - hipMidY_s);

        // If hips are visible, torso is too small, AND we are NOT in a state where hip occlusion is allowed
        // (i.e., not already ducking or potentially ducking with stable shoulders), then it's POSE_LOST.
        if (currentActualSmoothedTorsoHeight < CONFIG.minTorsoHeight && !allowHipWristOcclusion) {
            console.warn("Visible smoothed torso too small, and not in allowed occlusion mode. POSE_LOST.");
            if(gameState.ducking) gameState.ducking = false;
            return POSE_STATES.POSE_LOST;
        }
    }

    // ---- Recalibrate Standing References ----
    let torsoChangedSignificantly = false;
    if (currentActualSmoothedTorsoHeight && gameState.lastTorsoHeight) {
        torsoChangedSignificantly = Math.abs(currentActualSmoothedTorsoHeight - gameState.lastTorsoHeight) / gameState.lastTorsoHeight > CONFIG.torsoChangeThreshold;
    }

    // Conditions for recalibrating standing pose:
    // 1. Not initialized.
    // 2. Torso size changed significantly (user moved closer/further, hips must be visible for this) AND user is NOT currently ducking.
    if (!gameState.standingNoseY || (torsoChangedSignificantly && !gameState.ducking && lh && rh )) {
      console.log("Recalibrating standing references. Reason: " + (!gameState.standingNoseY ? "Init" : "TorsoChange"));
      gameState.standingNoseY = nose.y;
      if (currentActualSmoothedTorsoHeight) gameState.standingTorsoHeight = currentActualSmoothedTorsoHeight;
      gameState.standingShoulderWidth = smoothedShoulderWidth;
      if (torsoChangedSignificantly && gameState.ducking) { // If they were ducking and moved, reset duck.
          console.log("Forcing duck exit due to significant torso change during recalibration.");
          gameState.ducking = false;
      }
    }
    if (currentActualSmoothedTorsoHeight) { // Update lastTorsoHeight only if current is valid
        gameState.lastTorsoHeight = currentActualSmoothedTorsoHeight;
    }
    // ---- End Recalibration ----


    // ---- DUCK LOGIC ----
    let evaluatedDuckState = gameState.ducking; // Start with current state
    if (gameState.standingNoseY && gameState.standingTorsoHeight > 0) { // Ensure references are set
        const actualDropPixels = nose.y - gameState.standingNoseY;
        // Normalize drop against the torso height *when standing reference was set*
        const normalizedDrop = actualDropPixels / gameState.standingTorsoHeight;

        if (!gameState.ducking && normalizedDrop > CONFIG.duckThresholdRatio) {
            evaluatedDuckState = true;
            console.log(`DUCK detected. Drop: ${normalizedDrop.toFixed(2)} (RefT: ${gameState.standingTorsoHeight.toFixed(0)})`);
        } else if (gameState.ducking && normalizedDrop < CONFIG.duckThresholdRatio * CONFIG.duckExitFactor) {
            evaluatedDuckState = false;
            console.log(`Exited DUCK. Drop: ${normalizedDrop.toFixed(2)}. Recalibrating standing pose.`);
            // Recalibrate standing pose to current pose when standing up from a duck
            gameState.standingNoseY = nose.y;
            if (currentActualSmoothedTorsoHeight) {
                gameState.standingTorsoHeight = currentActualSmoothedTorsoHeight;
            } else if (gameState.lastTorsoHeight) { // Fallback if hips occluded on stand-up
                gameState.standingTorsoHeight = gameState.lastTorsoHeight;
            }
            gameState.standingShoulderWidth = smoothedShoulderWidth;
        }
    }
    gameState.ducking = evaluatedDuckState;

    if (gameState.ducking) {
        return POSE_STATES.DUCK;
    }
    // ---- END DUCK LOGIC ----

    // If not ducking, all original essential keypoints (including hips and wrists) must now be present for other poses.
    if (!lh || !rh) {
        // console.warn("Not ducking, but hips are missing. POSE_INCOMPLETE.");
        return POSE_STATES.POSE_INCOMPLETE;
    }
    if (!lw || !rw) {
        // console.warn("Not ducking, but wrists are missing. POSE_INCOMPLETE.");
        return POSE_STATES.POSE_INCOMPLETE;
    }

    // At this point, not ducking, and all standard keypoints (nose, shoulders, elbows, hips, wrists) are present and smoothed.
    const shoulderMidY = (ls.y + rs.y) / 2;
    const shoulderMidX = (ls.x + rs.x) / 2;
    const hipMidY = (lh.y + rh.y) / 2; // lh, rh are guaranteed here if not ducking
    const hipMidX = (lh.x + rh.x) / 2;

    // Lean
    const leanOffset = shoulderMidX - hipMidX;
    const leanThresh = CONFIG.leanThresholdX * smoothedShoulderWidth;
    if (leanOffset > leanThresh) return POSE_STATES.LEAN_LEFT;
    if (leanOffset < -leanThresh) return POSE_STATES.LEAN_RIGHT;

    // Punch
    const leftPunch = _checkPunch(lw, le, ls, true, shoulderMidY, smoothedShoulderWidth);
    const rightPunch = _checkPunch(rw, re, rs, false, shoulderMidY, smoothedShoulderWidth);
    if (leftPunch && rightPunch) return POSE_STATES.PUNCH_BOTH;
    if (leftPunch) return POSE_STATES.PUNCH_LEFT;
    if (rightPunch) return POSE_STATES.PUNCH_RIGHT;

    return POSE_STATES.IDLE;
  }

  function drawKeypoints(ctx) {
    ctx.fillStyle = 'lime';
    ctx.strokeStyle = 'yellow';
    ctx.lineWidth = 2;

    // Draw based on smoothedKeypoints state, which contains all successfully smoothed KPs for the frame
    for (const name of essentialNames) { // Iterate through all possible essential names
        const kp = gameState.smoothedKeypoints[name];
        // Check if kp exists for this name, and if its score (from last update) is good.
        // Also check if this kp was actually part of the 'es' map in interpretPose this frame,
        // meaning it was used. Or simply draw all smoothed ones that have a decent score.
        // For simplicity, draw if smoothed and score is good.
        if (kp && kp.score >= CONFIG.minPoseConfidence) {
            ctx.beginPath();
            ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
    }
  }

  function setupConfigControls() {
    const configVarsListDiv = document.getElementById('config-vars-list');
    const statusP = document.getElementById('configStatus');
    configVarsListDiv.innerHTML = '';

    Object.entries(CONFIG).forEach(([varName, currentValue]) => {
        const varRowDiv = document.createElement('div');
        const label = document.createElement('label');
        label.htmlFor = `config_input_${varName}`;
        label.textContent = `${varName}:`;
        varRowDiv.appendChild(label);

        const input = document.createElement('input');
        input.type = 'number';
        input.id = `config_input_${varName}`;
        input.value = currentValue;

        if (integerConfigVars.includes(varName)) {
            input.step = "1";
        } else {
            // Determine step based on common precision for these kinds of vars
            if (['minPoseConfidence', 'poseSmoothFactor', 'torsoChangeThreshold',
                 'leanThresholdX', 'punchThresholdX', 'shoulderWidthToleranceForDuckOcclusion',
                 'duckExitFactor'].includes(varName)) {
                input.step = "0.01";
            } else if (varName === 'duckThresholdRatio') {
                 input.step = "0.05";
            }
            else {
                input.step = "0.1";
            }
        }
        varRowDiv.appendChild(input);

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Update';
        applyBtn.dataset.varname = varName;
        varRowDiv.appendChild(applyBtn);

        applyBtn.addEventListener('click', () => {
            const selectedVar = varName;
            const newValueStr = input.value;
            let newValue;

            if (integerConfigVars.includes(selectedVar)) {
                newValue = parseInt(newValueStr, 10);
            } else {
                newValue = parseFloat(newValueStr);
            }

            if (isNaN(newValue)) {
                statusP.textContent = `Error: Invalid number for ${selectedVar}.`;
                statusP.style.color = '#ff6b6b';
                input.value = CONFIG[selectedVar];
                return;
            }

            CONFIG[selectedVar] = newValue;
            input.value = newValue;
            statusP.textContent = `${selectedVar} updated to ${CONFIG[selectedVar]}.`;
            statusP.style.color = '#7f7';
            console.log('CONFIG updated:', JSON.parse(JSON.stringify(CONFIG)));
        });
        configVarsListDiv.appendChild(varRowDiv);
    });
    statusP.textContent = 'Config loaded. Adjust values and click "Update".';
  }

  async function main() {
    await tf.setBackend('webgl');
    await tf.ready();
    console.log('TF backend:', tf.getBackend());

    const video = document.getElementById('video');
    const canvas = document.getElementById('overlay');
    const ctx = canvas.getContext('2d');
    const poseTextEl = document.getElementById('poseText');

    setupConfigControls();

    const stream = await navigator.mediaDevices.getUserMedia({video: {width: 640, height: 480}});
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    video.play().catch(e => {
        console.error("Video play failed:", e);
    });

    const detector = await poseDetection.createDetector(
      poseDetection.SupportedModels.MoveNet,
      {modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING}
    );

    poseTextEl.innerText = 'Ready!';

    async function frameLoop() {
      if (video.readyState < video.HAVE_METADATA || video.paused || video.ended) {
          requestAnimationFrame(frameLoop);
          return;
      }

      if (canvas.width !== video.clientWidth || canvas.height !== video.clientHeight) {
          canvas.width = video.clientWidth;
          canvas.height = video.clientHeight;
      }

      const poses = await detector.estimatePoses(video, {flipHorizontal: false});
      const estimatedState = interpretPose(poses[0]?.keypoints || []); // Pass raw keypoints

      if (estimatedState !== POSE_STATES.POSE_TEMPORARILY_INCOMPLETE) {
        poseTextEl.innerText = estimatedState;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (poses[0]?.keypoints && video.videoWidth > 0 && video.videoHeight > 0) {
          ctx.save();
          const videoAspectRatio = video.videoWidth / video.videoHeight;
          const canvasAspectRatio = canvas.width / canvas.height;
          let renderWidth, renderHeight, offsetX = 0, offsetY = 0;

          if (videoAspectRatio > canvasAspectRatio) {
              renderWidth = canvas.width;
              renderHeight = renderWidth / videoAspectRatio;
              offsetY = (canvas.height - renderHeight) / 2;
          } else {
              renderHeight = canvas.height;
              renderWidth = renderHeight * videoAspectRatio;
              offsetX = (canvas.width - renderWidth) / 2;
          }
          ctx.translate(offsetX, offsetY);
          ctx.scale(renderWidth / video.videoWidth, renderHeight / video.videoHeight);
          drawKeypoints(ctx);
          ctx.restore();
      }
      requestAnimationFrame(frameLoop);
    }
    frameLoop();
  }

  main().catch(e => {
    console.error(e);
    document.getElementById('poseText').innerText = 'Critical Error!';
  });
  </script>
</body>
</html>
