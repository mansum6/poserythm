<!DOCTYPE html>
<html>
<head>
  <title>MoveNet Pose Detector</title>
  <style>
    body, html { 
      margin: 0; 
      height: 100vh; /* Use vh for full viewport height */
      display: flex; 
      flex-direction: column;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      overflow: hidden; /* Prevent body scrollbars */
    }
    #poseDisplay { 
      flex: 0 0 20%; 
      font-size: 4em; 
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #333;
      color: #fff;
      margin: 0;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    #videoContainer { 
      flex: 0 0 40%; 
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center; /* Center video if it's pillar/letterboxed */
      background-color: #222;
      overflow: hidden; /* Ensure video/canvas don't overflow */
    }
    #webcam {
      height: 100%;
      width: 100%;
      object-fit: contain; /* Scale video to fit, maintain aspect ratio */
      max-height: 100%; /* Ensure it doesn't exceed container */
      max-width: 100%;  /* Ensure it doesn't exceed container */
      /* position: absolute; - Not needed if videoContainer uses flex to center */
    }
    #overlay {
      height: 100%;
      width: 100%; /* Match video container for scaling */
      max-height: 100%;
      max-width: 100%;
      position: absolute; /* Overlay on top of video */
      top: 0;
      left: 0;
      pointer-events: none; /* Allow interaction with video if needed */
      z-index: 10;
    }
    #controls { 
      flex: 0 0 35%; /* Adjusted height */
      padding: 1em; 
      overflow-y: auto; /* Scroll if content overflows */
      background-color: #fff;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
    }
    .control-group {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      grid-gap: 15px;
      margin-bottom: 20px;
    }
    .control-item {
      display: flex;
      flex-direction: column;
    }
    .control-item label {
      margin-bottom: 5px;
      font-weight: bold;
      color: #555;
    }
    .control-item input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button {
      background-color: #4285f4;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
      margin-top: 10px;
    }
    button:hover {
      background-color: #3367d6;
    }
    /* Removed .status class as its element is gone */

    #consoleArea {
      flex: 0 0 5%; /* Bottom 5% */
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 8px;
      overflow-y: auto;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 0.85em;
      border-top: 1px solid #333;
      box-sizing: border-box;
    }
    #consoleArea .log-entry {
      margin-bottom: 4px;
      white-space: pre-wrap; /* Allow wrapping and preserve newlines */
      word-break: break-all;
    }
    #consoleArea .log-entry .timestamp {
      color: #888;
      margin-right: 5px;
    }
    #consoleArea .log-error {
      color: #f48771; /* Softer red */
    }
    #consoleArea .log-info {
      color: #4ec9b0; /* Teal for info */
    }
    #consoleArea .log-message { /* Default log messages */
      color: #9cdcfe; /* Light blue for default console.log */
    }

  </style>
  <script type="importmap">
  {
    "imports": {
      "@tensorflow/tfjs": "https://esm.sh/@tensorflow/tfjs@4.20.0",
      "@tensorflow-models/pose-detection": "https://cdn.skypack.dev/@tensorflow-models/pose-detection@2.1.3"
    }
  }
  </script>
</head>
<body>
  <div id="poseDisplay">Initializing...</div>
  <div id="videoContainer">
    <video id="webcam" autoplay muted playsinline></video>
    <canvas id="overlay"></canvas>
  </div>
  <div id="controls">
    <h2>Pose Detection Settings</h2>
    <div id="controlInputs" class="control-group">
      <!-- Dynamically generated inputs for CONFIG go here -->
    </div>
    <button id="resetBtn">Reset Defaults</button>
    <!-- Removed status div from here -->
  </div>
  <div id="consoleArea">
    <!-- Console messages will appear here -->
  </div>

  <script type="module">
    import * as tf from '@tensorflow/tfjs';
    import * as poseDetection from '@tensorflow-models/pose-detection';

    let consoleAreaElement = null;
    const OGLOG = console.log;
    const OGERROR = console.error;

    function logToPanel(message, type = 'message') { // type can be 'message', 'info', 'error'
        if (!consoleAreaElement) { // Fallback to browser console if UI element not ready
            (type === 'error' ? OGERROR : OGLOG)(message);
            return;
        }
        const entry = document.createElement('div');
        entry.className = 'log-entry';

        const timestampSpan = document.createElement('span');
        timestampSpan.className = 'timestamp';
        timestampSpan.textContent = `[${new Date().toLocaleTimeString()}]`;
        
        const messageSpan = document.createElement('span');
        messageSpan.textContent = message;

        entry.appendChild(timestampSpan);
        entry.appendChild(messageSpan);

        if (type === 'error') {
            entry.classList.add('log-error');
        } else if (type === 'info') {
            entry.classList.add('log-info');
        } else {
            entry.classList.add('log-message');
        }
        
        consoleAreaElement.appendChild(entry);
        consoleAreaElement.scrollTop = consoleAreaElement.scrollHeight;
    }
    
    console.log = function(...args) {
        OGLOG.apply(console, args); // Keep original browser console behavior
        const message = args.map(arg => (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg, null, 2) : String(arg)).join(' ');
        logToPanel(message, 'message');
    };

    console.error = function(...args) {
        OGERROR.apply(console, args); // Keep original browser console behavior
        let messageContent = args.map(arg => {
            if (arg instanceof Error) {
                return `${arg.name ? arg.name + ": " : ""}${arg.message}${arg.stack ? `\nStack: ${arg.stack}` : ''}`;
            }
            return (typeof arg === 'object' && arg !== null) ? JSON.stringify(arg, null, 2) : String(arg);
        }).join(' ');
        logToPanel(messageContent, 'error');
    };


    // 1. Define keypoints & states
    const essentialKeypointNames = [
      "nose", "left_shoulder", "right_shoulder",
      "left_hip", "right_hip", "left_wrist",
      "right_wrist", "left_elbow", "right_elbow"
    ];
    
    const POSE_STATES = {
      IDLE: 'IDLE',
      LEAN_LEFT: 'LEAN LEFT',
      LEAN_RIGHT: 'LEAN RIGHT',
      DUCK: 'DUCK',
      PUNCH_LEFT: 'PUNCH LEFT',
      PUNCH_RIGHT: 'PUNCH RIGHT',
      PUNCH_BOTH: 'PUNCH BOTH',
      POSE_TEMPORARILY_INCOMPLETE: 'POSE INCOMPLETE (TEMP)',
      POSE_INCOMPLETE: 'POSE INCOMPLETE',
      POSE_LOST: 'POSE LOST'
    };

    // 2. Central CONFIG with default values
    const CONFIG = {
      leanAngleThreshold: 15,
      duckYThreshold: 0.2,
      punchExtensionThreshold: 0.3,
      incompleteGracePeriod: 15,
      smoothingFactor: 0.8
    };

    // Default CONFIG for reset
    const DEFAULT_CONFIG = { ...CONFIG };

    // Global variables
    let detector;
    let webcamElement, canvasElement, canvasCtx;
    let currentPose = POSE_STATES.POSE_LOST;
    let smoothedKeypoints = [];
    let incompleteFrameCount = 0;
    let baselineNoseY = null;
    let videoStreamActive = false;
    
    // 3. Setup webcam and model
    async function init() {
      webcamElement = document.getElementById('webcam');
      canvasElement = document.getElementById('overlay');
      canvasCtx = canvasElement.getContext('2d');
      
      try {
        logToPanel("Initializing TensorFlow.js...", 'info');
        await tf.ready();
        logToPanel(`Using TensorFlow backend: ${tf.getBackend()}`, 'info');
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user' }
        });
        webcamElement.srcObject = stream;
        
        await new Promise(resolve => {
          webcamElement.onloadedmetadata = () => {
            webcamElement.play(); // Start playing the video
            videoStreamActive = true;

            // Set canvas dimensions to match video's intrinsic dimensions
            // CSS will handle scaling the display of both video and canvas
            const videoWidth = webcamElement.videoWidth;
            const videoHeight = webcamElement.videoHeight;
            
            // These set the drawing surface size, not the display size
            canvasElement.width = videoWidth;
            canvasElement.height = videoHeight;

            // Adjust #overlay CSS if video is letterboxed/pillarboxed by object-fit: contain
            // This ensures the canvas drawing area is precisely over the visible video.
            const videoCssWidth = webcamElement.clientWidth;
            const videoCssHeight = webcamElement.clientHeight;
            
            // Calculate scale factors if video is letterboxed/pillarboxed
            const scaleX = videoCssWidth / videoWidth;
            const scaleY = videoCssHeight / videoHeight;
            const scale = Math.min(scaleX, scaleY); // Use the smaller scale to fit

            const effectiveCanvasWidth = videoWidth * scale;
            const effectiveCanvasHeight = videoHeight * scale;

            // Center the canvas overlay over the 'contained' video
            canvasElement.style.width = `${effectiveCanvasWidth}px`;
            canvasElement.style.height = `${effectiveCanvasHeight}px`;
            canvasElement.style.left = `${(videoCssWidth - effectiveCanvasWidth) / 2}px`;
            canvasElement.style.top = `${(videoCssHeight - effectiveCanvasHeight) / 2}px`;
            
            logToPanel(`Webcam initialized: ${videoWidth}x${videoHeight}. Displayed: ${videoCssWidth}x${videoCssHeight}`, 'info');
            resolve();
          };
        });
                
        logToPanel("Loading MoveNet model...", 'info');
        detector = await poseDetection.createDetector(
          poseDetection.SupportedModels.MoveNet,
          {
            modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
            enableSmoothing: false 
          }
        );
        logToPanel("MoveNet loaded! Detecting poses...", 'info');
        
        detectPose();
      } catch (error) {
        console.error("Initialization Error:", error); // Will also log to panel
      }
    }

    // 4. Main loop
    async function detectPose() {
      if (detector && webcamElement.readyState === 4 && videoStreamActive) {
        try {
          const poses = await detector.estimatePoses(webcamElement);
          
          if (poses.length > 0) {
            const pose = poses[0];
            smoothedKeypoints = smoothKeypoints(pose.keypoints, smoothedKeypoints);
            classifyPose(smoothedKeypoints);
            renderOverlay(smoothedKeypoints);
          } else {
            handlePoseLost();
          }
        } catch (error) {
          console.error('Error in pose detection loop:', error);
        }
      }
      
      requestAnimationFrame(detectPose);
    }
    
    function smoothKeypoints(newKeypoints, prevKeypoints) {
      if (!prevKeypoints || prevKeypoints.length === 0) {
        return [...newKeypoints];
      }
      const alpha = CONFIG.smoothingFactor; // Use current config
      return newKeypoints.map((keypoint, i) => ({
        ...keypoint,
        x: alpha * prevKeypoints[i].x + (1 - alpha) * keypoint.x,
        y: alpha * prevKeypoints[i].y + (1 - alpha) * keypoint.y,
        score: keypoint.score
      }));
    }
    
    function checkEssentialKeypoints(keypoints) {
      const keypointMap = {};
      keypoints.forEach(kp => keypointMap[kp.name] = kp);
      const missingKeypoints = essentialKeypointNames.filter(name => 
        !keypointMap[name] || keypointMap[name].score < 0.3
      );
      return {
        allVisible: missingKeypoints.length === 0,
        missingCount: missingKeypoints.length,
        missing: missingKeypoints
      };
    }
    
    function calculateAngle(pointA, pointB, pointC) {
      const angleAB = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x);
      const angleBC = Math.atan2(pointC.y - pointB.y, pointC.x - pointB.x);
      let angle = (angleAB - angleBC) * 180 / Math.PI;
      if (angle < 0) angle += 360;
      if (angle > 180) angle = 360 - angle;
      return angle;
    }
    
    function calculateDistance(pointA, pointB) {
      return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
    }
    
    function classifyPose(keypoints) {
      const kp = {};
      keypoints.forEach(keypoint => kp[keypoint.name] = keypoint);
      const keypointCheck = checkEssentialKeypoints(keypoints);
      
      if (!keypointCheck.allVisible) {
        if (keypointCheck.missingCount > essentialKeypointNames.length / 2) {
          currentPose = POSE_STATES.POSE_LOST;
          incompleteFrameCount = 0;
        } else {
          incompleteFrameCount++;
          currentPose = incompleteFrameCount < CONFIG.incompleteGracePeriod 
                        ? POSE_STATES.POSE_TEMPORARILY_INCOMPLETE 
                        : POSE_STATES.POSE_INCOMPLETE;
        }
        document.getElementById('poseDisplay').textContent = currentPose;
        return;
      }
      incompleteFrameCount = 0;
      
      if (baselineNoseY === null && kp.nose) baselineNoseY = kp.nose.y;
      
      let newPose = POSE_STATES.IDLE;
      
      if (baselineNoseY && kp.nose) {
        const noseYDrop = (kp.nose.y - baselineNoseY) / canvasElement.height;
        if (noseYDrop > CONFIG.duckYThreshold) newPose = POSE_STATES.DUCK;
        else baselineNoseY = baselineNoseY * 0.95 + kp.nose.y * 0.05;
      }
      
      if (kp.left_shoulder && kp.right_shoulder && kp.left_hip && kp.right_hip) {
        const midShoulder = { x: (kp.left_shoulder.x + kp.right_shoulder.x) / 2, y: (kp.left_shoulder.y + kp.right_shoulder.y) / 2 };
        const midHip = { x: (kp.left_hip.x + kp.right_hip.x) / 2, y: (kp.left_hip.y + kp.right_hip.y) / 2 };
        const verticalAngle = Math.atan2(midShoulder.x - midHip.x, midHip.y - midShoulder.y) * 180 / Math.PI;
        
        if (verticalAngle < -CONFIG.leanAngleThreshold) newPose = POSE_STATES.LEAN_LEFT;
        else if (verticalAngle > CONFIG.leanAngleThreshold) newPose = POSE_STATES.LEAN_RIGHT;
      }
      
      if (newPose === POSE_STATES.IDLE && kp.left_shoulder && kp.right_shoulder && kp.left_wrist && kp.right_wrist) {
        const shoulderWidth = calculateDistance(kp.left_shoulder, kp.right_shoulder);
        const leftArmExtension = calculateDistance(kp.left_wrist, kp.left_shoulder) / shoulderWidth;
        const rightArmExtension = calculateDistance(kp.right_wrist, kp.right_shoulder) / shoulderWidth;
        const leftPunch = leftArmExtension > CONFIG.punchExtensionThreshold;
        const rightPunch = rightArmExtension > CONFIG.punchExtensionThreshold;
        
        if (leftPunch && rightPunch) newPose = POSE_STATES.PUNCH_BOTH;
        else if (leftPunch) newPose = POSE_STATES.PUNCH_LEFT;
        else if (rightPunch) newPose = POSE_STATES.PUNCH_RIGHT;
      }
      
      currentPose = newPose;
      document.getElementById('poseDisplay').textContent = currentPose;
    }
    
    function handlePoseLost() {
      currentPose = POSE_STATES.POSE_LOST;
      document.getElementById('poseDisplay').textContent = currentPose;
      if (canvasCtx && canvasElement) {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      }
    }
    
    function renderOverlay(keypoints) {
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      keypoints.forEach(keypoint => {
        if (keypoint.score > 0.3) {
          canvasCtx.fillStyle = '#00FF00';
          canvasCtx.beginPath();
          canvasCtx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
          canvasCtx.fill();
          // canvasCtx.fillStyle = 'white';
          // canvasCtx.font = '12px Arial';
          // canvasCtx.fillText(keypoint.name, keypoint.x + 8, keypoint.y);
        }
      });
      
      const connections = [
        ['nose', 'left_eye'], ['nose', 'right_eye'], ['left_eye', 'left_ear'], ['right_eye', 'right_ear'],
        ['nose', 'left_shoulder'], ['nose', 'right_shoulder'], ['left_shoulder', 'right_shoulder'],
        ['left_shoulder', 'left_elbow'], ['right_shoulder', 'right_elbow'], ['left_elbow', 'left_wrist'], ['right_elbow', 'right_wrist'],
        ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
        ['left_hip', 'left_knee'], ['right_hip', 'right_knee'], ['left_knee', 'left_ankle'], ['right_knee', 'right_ankle']
      ];
      const keypointMap = {};
      keypoints.forEach(kp => keypointMap[kp.name] = kp);
      
      canvasCtx.strokeStyle = '#00FF00';
      canvasCtx.lineWidth = 2;
      connections.forEach(([from, to]) => {
        const fromKP = keypointMap[from];
        const toKP = keypointMap[to];
        if (fromKP && toKP && fromKP.score > 0.3 && toKP.score > 0.3) {
          canvasCtx.beginPath();
          canvasCtx.moveTo(fromKP.x, fromKP.y);
          canvasCtx.lineTo(toKP.x, toKP.y);
          canvasCtx.stroke();
        }
      });
      document.getElementById('poseDisplay').textContent = currentPose;
    }

    function buildControls() {
      const controlsContainer = document.getElementById('controlInputs');
      for (const [key, value] of Object.entries(CONFIG)) {
        const controlDiv = document.createElement('div');
        controlDiv.className = 'control-item';
        const label = document.createElement('label');
        label.textContent = formatLabel(key);
        label.htmlFor = `input-${key}`;
        const input = document.createElement('input');
        input.type = 'number';
        input.id = `input-${key}`;
        input.value = value;
        input.step = key.includes('Factor') || key.includes('ThresholdY') ? '0.05' : '1';
        
        input.addEventListener('change', () => {
          CONFIG[key] = parseFloat(input.value);
          logToPanel(`Updated ${formatLabel(key)} to ${input.value}`, 'info');
        });
        
        controlDiv.appendChild(label);
        controlDiv.appendChild(input);
        controlsContainer.appendChild(controlDiv);
      }
      
      document.getElementById('resetBtn').addEventListener('click', () => {
        Object.keys(CONFIG).forEach(key => {
          CONFIG[key] = DEFAULT_CONFIG[key];
          document.getElementById(`input-${key}`).value = DEFAULT_CONFIG[key];
        });
        logToPanel('All settings reset to defaults', 'info');
      });
    }
    
    function formatLabel(key) {
      return key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
    }

    window.addEventListener('load', () => {
      consoleAreaElement = document.getElementById('consoleArea'); // Initialize console DOM element
      logToPanel("Application loading...", "info");
      init();
      buildControls();
      logToPanel("Application initialized. UI console is active.", "info");
    });
  </script>
</body>
</html>
